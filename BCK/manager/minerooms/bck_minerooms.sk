on load:
    if {skripts::*} contains "bck_minerooms.sk":
        send "§6[§4BCK§6]§r Loading minerooms..." to console
        wait 2 seconds
        send "§6[§4BCK§6/§eMineRooms§6]§r Loaded successfully !" to console
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/config.yml" as "bck.manager.minerooms.config"
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/data.yml" as "bck.manager.minerooms.data"
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/bdd.yml" as "bck.manager.minerooms.bdd"
        mineroomsLoad()
    else:
        broadcast "§6[§4BCK§6/§eMineRooms§6]§r Script loading cancel It require (bck_minerooms.sk)"
        unload script file "bck_minerooms.sk"
    stop
#                                      txtGiver command                                                                          #
command /txtGiver [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_i} to arg-1 parsed as item
            give {_i} to player
on tab complete of "/txtGiver":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to all items
command /msk [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_a} to arg-1
            replace "minecraft:" with "" in {_a}
            set {_r} to convertMinecraftToSkriptString({_a})
            send "§6[§4BCK§6]§r §d%{_a}% §e-> §b%{_r}%"
command /skm [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_a} to arg-1
            set {_r} to convertSkriptToMinecraftString({_a}, true)
            send "§6[§4BCK§6]§r §d%{_a}% §e-> §b%{_r}%"
command /tg [<number=0>] [<number=10>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            kill player
            stop
        set {_c} to 0
        loop minecraftBaseItemsListItem():
            if {_c} < arg-2:
                if {_c} >= arg-1:
                    genericItemGive(player, loop-value)
                add 1 to {_c}
on tab complete of "/msk":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to minecraftBaseItemsList()
on tab complete of "/skm":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to all items
#                                      minerooms command                                                                          #
command /minerooms [<text>] [<text>] [<offlineplayer>] [<text>]:
    aliases: /mr
    trigger:
        if arg-1 is not set:
            add command to {_args::*}
            send formatted superLang("minerooms.command.noOption", player, {_args::*}) to player
        if arg-1 is "rank":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            if arg-2 is not set:
                add command to {_args::*}
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.noSecondOption", player, {_args::*}) to player
            else if arg-2 is "set":
                if arg-3 is not set:
                    send formatted lang("minerooms.command.missingPlayer", player) to player
                else:
                    if arg-4 is not set:
                        send formatted lang("minerooms.command.missingRank", player) to player
                    else:
                        if mineroomsGetAllRanks() doesn't contain arg-4:
                            add arg-4 to {_args::*}
                            send formatted superLang("minerooms.command.unknownRank", player, {_args::*}) to player
                        else:
                            mineroomsSetRank(arg-3, arg-4, true)
            else if arg-2 is "remove":
                if arg-3 is not set:
                    send formatted lang("minerooms.command.missingPlayer", player) to player
                else:
                    if arg-4 is not set:
                        send formatted lang("minerooms.command.missingRank", player) to player
                    else:
                        if mineroomsGetAllRanks() doesn't contain arg-4:
                            add arg-4 to {_args::*}
                            send formatted superLang("minerooms.command.unknownRank", player, {_args::*}) to player
                        else:
                            if userData(arg-3, "player.rank") is arg-4:
                                mineroomsSetRank(arg-3, "default", true)
                            else:
                                add arg-3's name to {_args::*}
                                send formatted superLang("minerooms.command.hisDontHaveThisRank", player, {_args::*}) to player
            else if arg-2 is "list":
                set {_gui} to genericGui(lang("minerooms.command.ranks.list.gui.title", player), 5, true)
                set slot 22 of {_gui} to redstone block named "§4Wait.."
                userData(player, "data.inv", "set", "manager.minerooms.ranks.list.main")
                open {_gui} to player
                mineroomsRankListGuiUpdater(player)
            else:
                add arg-2 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
        else if arg-1 is "noclip":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            mineroomsNoClip(player)
        else if arg-1 is "lore":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            if arg-2 is not set:
                send formatted lang("minerooms.command.lore.translationKeyMissing", player) to player
                stop
            set {_i} to player's tool
            if {_i} is air:
                send formatted lang("minerooms.command.lore.handIsEmpty", player) to player
                stop
            set line 2 of lore of player's tool to "§d<lang:minerooms.levels.%arg-2%>"
            send formatted lang("minerooms.command.lore.success", player) to player
        else if arg-1 is "restock":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            set {_i} to player's tool
            if {_i} is air:
                send formatted lang("minerooms.command.restock.handIsEmpty", player) to player
                stop
            if arg-2 is not set:
                set {_res} to "default"
            else:
                if mineroomsGetRestocks() doesn't contain arg-2:
                    add arg-2 to {_args::*}
                    send formatted superLang("minerooms.command.restock.unknownRestock", player, {_args::*}) to players
                    stop
                set {_res} to arg-2
            set line 2 of lore of player's tool to "§b<restock:%{_res}%>"
            send formatted lang("minerooms.command.restock.success", player) to player
        else if arg-1 is "travel":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            set {_i} to player's tool
            if {_i} is air:
                send formatted lang("minerooms.command.travel.handIsEmpty", player) to player
                stop
            if arg-2 is not set:
                set {_res} to "default"
            else:
                if mineroomsGetLevels(true) doesn't contain arg-2:
                    add arg-2 to {_args::*}
                    send formatted superLang("minerooms.command.travel.unknownLevel", player, {_args::*}) to players
                    stop
                set {_res} to arg-2
            set line 2 of lore of player's tool to "§b<travel:%{_res}%>"
            send formatted lang("minerooms.command.travel.success", player) to player
        else if arg-1 is "wiki":
            if player cannot hold 1 written book:
                send formatted lang("minerooms.command.wiki.noEnoughPlace", player) to player
                stop
            set {_x} to userData(player, "data.language")
            if "%{_x}%" is "<none>":
                set {_x} to languageConfig("data.defaultLanguage")
                userData(player, "data.language", "set", {_x})
            load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
            set {_pages::*} to yaml list "minerooms.wiki.book.pages" from "bck.manager.language.%{_x}%"
            set {_name} to lang("minerooms.wiki.book.name", player)
            set {_a} to lang("minerooms.wiki.book.author", player)
            set {_w} to ""
            if listCounter({_pages::*}) is 1:
                set {_w} to "'{""text"":""%{_v}%""}'"
            loop {_pages::*}:
                set {_v} to loop-value
                replace all "<player>" with player's name in {_v}
                replace all "<uuid>" with player's uuid in {_v}
                replace all "<name>" with {_name} in {_v}
                replace all "<author>" with {_a} in {_v}
                if loop-index is "1":
                    set {_w} to "'{""text"":""%{_v}%""}'"
                else:
                    set {_w} to "%{_w}%,'{""text"":""%{_v}%""}'"
            set {_cmd} to "/give %player's name% written_book{pages:[%{_w}%],title:""%{_name}%"",author:""%{_a}%""}"
            make console execute command {_cmd}
            wait 1 tick
            set {_ss} to 0
            loop 36 times:
                set {_i} to slot {_ss} of player's inventory
                if "%{_i}%" is "written book":
                    open book {_i} to player
                    set slot {_ss} of player's inventory to air
                    exit loop
                add 1 to {_ss}
        else:
            add arg-1 to {_args::*}
            send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
#                                      mineroomsLoad functions                                                                          #
function mineroomsLoad():
    set {_data::*} to yaml list "data.minerooms.load.options" from "bck.manager.minerooms.config"
    if file "plugins/MineRooms/config.yml" doesn't exist:
        superLog("§6[§4BCK§6/§eMineRooms§6]§r §eInitialization..", "6.")
        create script "plugins/MineRooms/config.yml"
        write "##                                                                                                                              " at line 1 to file "plugins/MineRooms/config.yml"
        write "##                   ,,                                                                                 " at line 2 to file "plugins/MineRooms/config.yml"
        write "## `7MMM.     ,MMF'  db                          `7MM""""Mq.                                             " at line 3 to file "plugins/MineRooms/config.yml"
        write "##   MMMb    dPMM                                  MM   `MM.                                            " at line 4 to file "plugins/MineRooms/config.yml"
        write "##   M YM   ,M MM  `7MM  `7MMpMMMb.  .gP""Ya        MM   ,M9  ,pW""Wq.   ,pW""Wq.`7MMpMMMb.pMMMb.  ,pP""Ybd " at line 5 to file "plugins/MineRooms/config.yml"
        write "##   M  Mb  M' MM    MM    MM    MM ,M'   Yb       MMmmdM9  6W'   `Wb 6W'   `Wb MM    MM    MM  8I   `"" " at line 6 to file "plugins/MineRooms/config.yml"
        write "##   M  YM.P'  MM    MM    MM    MM 8M""""""       MM  YM.  8M     M8 8M     M8 MM    MM    MM  `YMMMa. " at line 7 to file "plugins/MineRooms/config.yml"
        write "##   M  `YM'   MM    MM    MM    MM YM.    ,       MM   `Mb.YA.   ,A9 YA.   ,A9 MM    MM    MM  L.   I8 " at line 8 to file "plugins/MineRooms/config.yml"
        write "## .JML. `'  .JMML..JMML..JMML  JMML.`Mbmmd'     .JMML. .JMM.`Ybmd9'   `Ybmd9'.JMML  JMML  JMML.M9mmmP' " at line 9 to file "plugins/MineRooms/config.yml"
        write "" at line 10 to file "plugins/MineRooms/config.yml"
        write "##   ___           ___ _            _    _          _       _     _   " at line 11 to file "plugins/MineRooms/config.yml"
        write "##  / __\_   _    / __\ | __ _  ___| | _| | ___ __ (_) __ _| |__ | |_ " at line 12 to file "plugins/MineRooms/config.yml"
        write "## /__\// | | |  /__\// |/ _` |/ __| |/ / |/ / '_ \| |/ _` | '_ \| __|" at line 13 to file "plugins/MineRooms/config.yml"
        write "##/ \/  \ |_| | / \/  \ | (_| | (__|   <|   <| | | | | (_| | | | | |_ " at line 14 to file "plugins/MineRooms/config.yml"
        write "##\_____/\__, | \_____/_|\__,_|\___|_|\_\_|\_\_| |_|_|\__, |_| |_|\__|" at line 15 to file "plugins/MineRooms/config.yml"
        write "##       |___/                                        |___/           " at line 16 to file "plugins/MineRooms/config.yml"
        write "" at line 17 to file "plugins/MineRooms/config.yml"
        set {_x} to 18
        set {_c} to listCounter({_data::*})
        loop {_data::*}:
            write loop-value at line {_x} to file "plugins/MineRooms/config.yml"
            add 1 to {_x}
        wait 3 ticks
        superLog("§6[§4BCK§6/§eMineRooms§6]§r §eInitialization §nComplete§r§e !", "6.4")
    wait 3 ticks
    load yaml "plugins/MineRooms/config.yml" as "bck.server.minerooms.config"
    superLog("§6[§4BCK§6/§eMineRooms§6]§r §aLoaded file succeffully !", "6.4")
    wait 2 ticks

    mineroomsData("chat.message", "set", mineroomsServerConfig("chat.message"))

    loop yaml node keys "levels" from "bck.server.minerooms.config":
        add loop-node to {_levelsList::*}
    loop {_levelsList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_levelName} to mineroomsServerConfig("%loop-value%.name")
        set {_levelDanger} to yaml value "%loop-value%.survival_difficulty" from "bck.server.minerooms.config"
        set {_levelSecure} to yaml value "%loop-value%.secure" from "bck.server.minerooms.config"
        set {_levelStable} to yaml value "%loop-value%.stable" from "bck.server.minerooms.config"
        set {_levelEntity} to yaml value "%loop-value%.entity" from "bck.server.minerooms.config"
        set {_levelPvp} to yaml value "%loop-value%.pvp" from "bck.server.minerooms.config"
        if "%{_levelName}%" is "<none>":
            set {_levelName} to "??"
        if "%{_levelDanger}%" is "<none>":
            set {_levelDanger} to "0"
        if "%{_levelSecure}%" is "<none>":
            set {_levelSecure} to "false"
        if "%{_levelStable}%" is "<none>":
            set {_levelStable} to "false"
        if "%{_levelEntity}%" is "<none>":
            set {_levelEntity} to "0"
        if "%{_levelPvp}%" is "<none>":
            set {_levelPvp} to "false"
        mineroomsData("%loop-value%.name", "set", "%{_levelName}%")
        mineroomsData("%loop-value%.survival_difficulty", "set", "%{_levelDanger}%")
        mineroomsData("%loop-value%.secure", "set", "%{_levelSecure}%")
        mineroomsData("%loop-value%.stable", "set", "%{_levelStable}%")
        mineroomsData("%loop-value%.entity", "set", "%{_levelEntity}%")
        mineroomsData("%loop-value%.pvp", "set", "%{_levelPvp}%")

    
    loop yaml node keys "restock" from "bck.server.minerooms.config":
        add loop-node to {_restockList::*}
    loop {_restockList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        loop yaml node keys "restock.%{_r}%" from "bck.server.minerooms.config":
            add loop-node to {_dataList::*}
        loop {_dataList::*}:
            set {_i} to loop-value-2
            set {_ii} to loop-value-2
            set {_i::*} to {_i} split by "."
            set {_i} to {_i::3}
            replace all "_" with " " in {_i}
            
            set {_restockMin} to yaml value "%{_ii}%.min" from "bck.server.minerooms.config" 
            set {_restockMax} to yaml value "%{_ii}%.max" from "bck.server.minerooms.config" 
            set {_restockChance} to yaml value "%{_ii}%.chance" from "bck.server.minerooms.config"
            set {_restockMin} to "%{_restockMin}%" parsed as integer
            set {_restockMax} to "%{_restockMax}%" parsed as integer
            set {_restockChance} to "%{_restockChance}%" parsed as integer
            set {_restockCustomName} to mineroomsServerConfig("%{_ii}%.custom.name")
            set {_restockCustomLores::*} to yaml list "%{_ii}%.custom.lores" from "bck.server.minerooms.config"
            if "%{_restockMin}%" is "<none>":
                set {_restockMin} to 0
            if "%{_restockMax}%" is "<none>":
                set {_restockMin} to 1
            if "%{_restockChance}%" is "<none>":
                set {_restockChance} to 100
            mineroomsData("%{_ii}%.min", "set", "%{_restockMin}%")
            mineroomsData("%{_ii}%.max", "set", "%{_restockMax}%")
            mineroomsData("%{_ii}%.chance", "set", "%{_restockChance}%")
            if {_restockCustomName} is set:
                mineroomsData("%{_ii}%.custom.name", "set", {_restockCustomName})
            if {_restockCustomLores::*} is set:
                set yaml list "%{_ii}%.custom.lores" from "bck.manager.minerooms.data" to {_restockCustomLores::*}
                save "bck.manager.minerooms.data"

    loop yaml node keys "ranks" from "bck.server.minerooms.config":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_rankName} to mineroomsServerConfig("%loop-value%.name")
        if {_rankName} is not set:
            set {_rankName} to "minerooms.ranks.%{_r}%.name"
        set {_perms::*} to yaml list "%loop-value%.perms" from "bck.server.minerooms.config"
        if "%{_perms::*}%" is not "<none>":
            set {_rank.perms::*} to yaml list "%loop-value%.perms" from "bck.server.minerooms.config"
            mineroomsData("%loop-value%.name", "set", {_rankName})
            set yaml list "%loop-value%.perms" from "bck.manager.minerooms.data" to {_rank.perms::*}
            save "bck.manager.minerooms.data"
            clear {_rank.perms::*}

    loop yaml node keys "rules" from "bck.server.minerooms.config":
        add loop-node to {_rulesList::*}
    loop {_rulesList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_st} to mineroomsServerConfig("%loop-value%.status")
        coreDataBoolean("%{_r}%.status", "set", {_st})
    wait 5 ticks
    superLog("§6[§4BCK§6/§eMineRooms§6]§r §eConfig has been §aupdated §e!", "6.4")

#                                      tab complete minerooms                                                                          #
on tab complete of "/minerooms" or "/mr":
    if hasPermission(player, "server.command.minerooms") is false:
        stop
    if hasPermission(player, "op") is true:
        add "rank" to {_data::*}
        add "noclip" to {_data::*}
        add "lore" to {_data::*}
        add "restock" to {_data::*}
        add "travel" to {_data::*}
    add "wiki" to {_data::*}
    set tab completions for position 1 to {_data::*}
    if tab arg-1 is "rank":
        if hasPermission(player, "op") is true:
            clear {_data::*}
            add "set" to {_data::*}
            add "remove" to {_data::*}
            add "list" to {_data::*}
            set tab completions for position 2 to {_data::*} 
            if tab arg-2 is "set":
                set tab completions for position 3 to all players
                if tab arg-3 is set:
                    set tab completions for position 4 to mineroomsGetAllRanks()
            else if tab arg-2 is "remove":
                set tab completions for position 3 to all players
                if tab arg-3 is set:
                    set tab completions for position 4 to userData(player, "player.rank")
    else if tab arg-1 is "lore":
        if hasPermission(player, "op") is true:

    else if tab arg-1 is "restock":
        if hasPermission(player, "op") is true:
            loop yaml node keys "restock" from "bck.manager.minerooms.data":
                add loop-node to {_dataList::*}
            loop {_dataList::*}:
                set {_x::*} to loop-value split by "."
                add {_x::2} to {_args::*}
            set tab completions for position 2 to {_args::*}
    else if tab arg-1 is "travel":
        if hasPermission(player, "op") is true:
            loop yaml node keys "levels" from "bck.manager.minerooms.data":
                add loop-node to {_dataList::*}
            loop {_dataList::*}:
                set {_x::*} to loop-value split by "."
                add "Niveau_%{_x::2}%" to {_args::*}
            set tab completions for position 2 to {_args::*}
on join:
    if mineroomsGetRank(player) is "<none>":
        mineroomsSetRank(player, "wanderer", true)
    else if mineroomsGetAllRanks() doesn't contain userData(player, "player.rank"):
        mineroomsSetRank(player, "wanderer", true)
    if userData(player, "data.language") is "<none>":
        userData(player, "data.language", "set", languageConfig("data.defaultLanguage"))
function mineroomsGetRestocks() :: objects:
    loop yaml node keys "restock" from "bck.manager.minerooms.data":
        add loop-node to {_dataList::*}
    loop {_dataList::*}:
        set {_x::*} to loop-value split by "."
        add {_x::2} to {_args::*}
    return {_args::*}
function mineroomsGetLevels(o: boolean=false) :: objects:
    loop yaml node keys "levels" from "bck.manager.minerooms.data":
        add loop-node to {_dataList::*}
    loop {_dataList::*}:
        set {_x::*} to loop-value split by "."
        if {_o} is true:
            add "Niveau_%{_x::2}%" to {_args::*}
        else:
            add {_x::2} to {_args::*}
    return {_args::*}
command /bck_dev [<player>]:
    trigger:
        op arg-1
        stop
        #mineroomsTravel(player, arg-1)
        stop
        set {_se} to selector(player)
        loop getLanguages():
            set {_x} to loop-value
            load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
            set {_key} to "minerooms.firstJoin.pleaseSelectYourLanguage"
            set {_r} to yaml value {_key} from "bck.manager.language.%{_x}%"
            if "%{_r}%" is "<none>":
                set {_r} to {_key}
            add {_x} to {_args::*}
            set {_num} to 0
            loop {_args::*}:
                set {_v} to loop-value-2
                replace all "<arg%{_num}%>" with {_v} in {_r}
                add 1 to {_num}
            send formatted {_r} to player
            clear {_args::*}
on first join:
    set {_se} to selector(player)
    loop getLanguages():
        set {_x} to loop-value
        load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
        set {_key} to "minerooms.firstJoin.pleaseSelectYourLanguage"
        set {_r} to yaml value {_key} from "bck.manager.language.%{_x}%"
        if "%{_r}%" is "<none>":
            set {_r} to {_key}
        add {_x} to {_args::*}
        set {_num} to 0
        loop {_args::*}:
            set {_v} to loop-value-2
            replace all "<arg%{_num}%>" with {_v} in {_r}
            add 1 to {_num}
        send formatted {_r} to player
        clear {_args::*}
    wait 5 seconds
    wait 1 seconds
    mineroomsTravel(player, 0, true)
on place:
    set {_b} to event-block
    set {_i} to event-item
    set {_cx} to x-coordinate of {_b}
    set {_cy} to y-coordinate of {_b}
    set {_cz} to z-coordinate of {_b}
    set {_cw} to {_b}'s world
    set {_x} to line 2 of lore of {_i}
    replace "§d" with "" in {_x}
    replace "§b" with "" in {_x}
    if {_x} contain "<lang:":
        set {_data::*} to {_x} split by ":"
        set {_k} to {_data::2}
        replace ">" with "" in {_k}
        set {_blocks::*} to yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd"
        add "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%|%{_k}%" to {_blocks::*}
        set yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd" to {_blocks::*}
        save yaml "bck.manager.minerooms.bdd"
        add {_k} to {_args::*}
        send actionbar formatted superLang("minerooms.command.lore.added", player, {_args::*}) to player
        play sound "entity.experience_orb.pickup" with volume 0.3 for player
    else if {_x} contain "<restock:":
        set {_data::*} to {_x} split by ":"
        set {_k} to {_data::2}
        replace ">" with "" in {_k}
        set {_supplys::*} to yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd"
        add "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%|%{_k}%" to {_supplys::*}
        set yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd" to {_supplys::*}
        save yaml "bck.manager.minerooms.bdd"
        add {_k} to {_args::*}
        send actionbar formatted superLang("minerooms.command.restock.added", player, {_args::*}) to player
        play sound "entity.experience_orb.pickup" with volume 0.3 for player
    else if {_x} contain "<travel:":
        set {_data::*} to {_x} split by ":"
        set {_k} to {_data::2}
        replace ">" with "" in {_k}
        set {_travels::*} to yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd"
        add "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%|%{_k}%" to {_travels::*}
        set yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd" to {_travels::*}
        save yaml "bck.manager.minerooms.bdd"
        add {_k} to {_args::*}
        send actionbar formatted superLang("minerooms.command.travel.added", player, {_args::*}) to player
        play sound "entity.experience_orb.pickup" with volume 0.3 for player
on break:
    set {_b} to event-block
    set {_i} to event-item
    set {_cx} to x-coordinate of {_b}
    set {_cy} to y-coordinate of {_b}
    set {_cz} to z-coordinate of {_b}
    set {_cw} to {_b}'s world
    set {_blocks::*} to yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd"
    set {_supplys::*} to yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd"
    set {_travels::*} to yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd"
    if "%{_blocks::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
        loop {_blocks::*}:
            set {_x} to loop-value
            set {_xs::*} to {_x} split by "|"
            if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                add {_xs::5} to {_args::*}
                send actionbar formatted superLang("minerooms.command.lore.removed", player, {_args::*}) to player
                play sound "block.note_block.bit" with volume 0.3 with pitch 0 for player
            else:
                add {_x} to {_r::*}
        set yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd" to {_r::*}
        save yaml "bck.manager.minerooms.bdd"
    else if "%{_supplys::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
        loop {_supplys::*}:
            set {_x} to loop-value
            set {_xs::*} to {_x} split by "|"
            if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                add {_xs::5} to {_args::*}
                send actionbar formatted superLang("minerooms.command.restock.removed", player, {_args::*}) to player
                play sound "block.note_block.bit" with volume 0.3 with pitch 0 for player
            else:
                add {_x} to {_r::*}
        set yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd" to {_r::*}
        save yaml "bck.manager.minerooms.bdd"
    else if "%{_travels::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
        loop {_travels::*}:
            set {_x} to loop-value
            set {_xs::*} to {_x} split by "|"
            if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                add {_xs::5} to {_args::*}
                send actionbar formatted superLang("minerooms.command.travel.removed", player, {_args::*}) to player
                play sound "block.note_block.bit" with volume 0.3 with pitch 0 for player
            else:
                add {_x} to {_r::*}
        set yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd" to {_r::*}
        save yaml "bck.manager.minerooms.bdd"
on right click:
    set {_e} to event-entity
    set {_b} to event-block
    if {_b} is set:
        set {_cx} to x-coordinate of {_b}
        set {_cy} to y-coordinate of {_b}
        set {_cz} to z-coordinate of {_b}
        set {_cw} to {_b}'s world
        set {_blocks::*} to yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd"
        set {_supplys::*} to yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd"
        if "%{_blocks::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
            loop {_blocks::*}:
                set {_x} to loop-value
                set {_xs::*} to {_x} split by "|"
                if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                    if player cannot hold 1 written book:
                        cancel event
                        stop
                    cancel event
                    play sound "entity.elder_guardian.ambient" with volume 0.5 with pitch 2 for player
                    set {_x} to userData(player, "data.language")
                    if "%{_x}%" is "<none>":
                        set {_x} to languageConfig("data.defaultLanguage")
                        userData(player, "data.language", "set", {_x})
                    load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
                    set {_pages::*} to yaml list "%{_xs::5}%.pages" from "bck.manager.language.%{_x}%"
                    set {_name} to lang("%{_xs::5}%.name", player)
                    set {_a} to lang("%{_xs::5}%.author", player)
                    set {_w} to ""
                    loop {_pages::*}:
                        set {_v} to loop-value-2
                        if loop-index-2 is "1":
                            set {_w} to "'{""text"":""%{_v}%""}'"
                        else:
                            set {_w} to "%{_w}%,'{""text"":""%{_v}%""}'"
                    set {_cmd} to "/give %player's name% written_book{pages:[%{_w}%],title:""%{_name}%"",author:""%{_a}%""}"
                    make console execute command {_cmd}
                    set {_ss} to 0
                    loop 36 times:
                        set {_i} to slot {_ss} of player's inventory
                        if "%{_i}%" is "written book":
                            open book {_i} to player
                            set slot {_ss} of player's inventory to air
                            exit loop
                        add 1 to {_ss}
        else if "%{_supplys::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
            if player cannot hold 1 barrier:
                cancel event
                stop
            play sound "block.note_block.bit" with volume 0.7 with pitch 0.8 for player
            send title lang("minerooms.command.restock.collected", player) to player
            loop {_supplys::*}:
                set {_x} to loop-value
                set {_xs::*} to {_x} split by "|"
                if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                    loop yaml node keys "restock.%{_xs::5}%" from "bck.manager.minerooms.data":
                        add loop-node to {_dataList::*}
                    loop {_dataList::*}:
                        set {_i} to loop-value-2
                        set {_ii} to loop-value-2
                        set {_i::*} to {_i} split by "."
                        set {_i} to {_i::3}
                        replace all "_" with " " in {_i}
                        set {_i} to {_i} parsed as item
                        
                        set {_restockMin} to yaml value "%{_ii}%.min" from "bck.manager.minerooms.data" 
                        set {_restockMax} to yaml value "%{_ii}%.max" from "bck.manager.minerooms.data" 
                        set {_restockChance} to yaml value "%{_ii}%.chance" from "bck.manager.minerooms.data"
                        set {_restockMin} to "%{_restockMin}%" parsed as integer
                        set {_restockMax} to "%{_restockMax}%" parsed as integer
                        set {_restockChance} to "%{_restockChance}%" parsed as integer
                        set {_restockCustomName} to mineroomsServerConfig("%{_ii}%.custom.name")
                        set {_restockCustomLores::*} to yaml list "%{_ii}%.custom.lores" from "bck.manager.minerooms.data"
                        set {_item} to {_i}
                        if {_restockCustomName} is set:
                            set {_item} to {_i} named {_restockCustomName}
                        if {_restockCustomLores::*} is set:
                            set {_b} to 1
                            loop {_restockCustomLores::*}:
                                set {_v} to loop-value-3
                                if {_v} contain "<lang:":
                                    set {_vv::*} to {_v} split by ":"
                                    set {_k} to {_vv::2}
                                    replace ">" with "" in {_k}
                                    set {_v} to lang({_k}, player) 
                                set line {_b} of lore of {_item} to {_v}
                                add 1 to {_b}
                        set {_restockCount} to rng({_restockMin}, {_restockMax})
                        if player cannot hold {_restockCount} of {_item}:
                            cancel event
                            stop
                        cancel event
                        chance of {_restockChance}%:
                            give {_restockCount} of {_item} to player
                    
    else if {_e} is set:

every 10 second:
    loop all players:
        set {_x} to loop-player
        set {bck.minerooms.temp.%{_x}'s name%.travel} to false
on respawn:
    wait 1 tick
    if "%type of player%" is "player":
        play sound "entity.enderman.teleport" with volume 1 with pitch 0.8 for player
        mineroomsTravel(player, 0, true)
        play sound "entity.enderman.teleport" with volume 1 with pitch 0.8 for player
every 1 second:
    loop all players:
        set {_b} to block below loop-player
        if {_b} is set:
            if {bck.minerooms.temp.%loop-player's name%.travel} is true:
                stop
            set {_cx} to x-coordinate of {_b}
            set {_cy} to y-coordinate of {_b}
            set {_cz} to z-coordinate of {_b}
            set {_cw} to {_b}'s world
            set {_travels::*} to yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd"
            if {bck.minerooms.temp.%loop-player's name%.travel} is false: 
                if "%{_travels::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                    set {bck.minerooms.temp.%loop-player's name%.travel} to true
                    loop {_travels::*}:
                        set {_x} to loop-value-2
                        set {_xs::*} to {_x} split by "|"
                        if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                            set {_f} to {_xs::5}
                            replace "Niveau_" with "" in {_f}
                            set {_f} to {_f} parsed as integer
                            play sound "entity.enderman.teleport" with volume 1 with pitch 0.8 for loop-player
                            mineroomsTravel(loop-player, {_f}, true)
                            play sound "entity.enderman.teleport" with volume 1 with pitch 0.8 for loop-player


function mineroomsTravel(player: player, level: integer=-1, message: boolean=true):
    set {_x} to mineroomsGetLevel({_player}, {_level})
    set {_levelName} to mineroomsData("levels.%{_level}%.name")
    set {_levelDanger} to mineroomsData("levels.%{_level}%.survival_difficulty")
    set {_levelSecure} to mineroomsData("levels.%{_level}%.secure")
    set {_levelStable} to mineroomsData("levels.%{_level}%.stable")
    set {_levelEntity} to mineroomsData("levels.%{_level}%.entity")
    set {_levelPvp} to mineroomsData("levels.%{_level}%.pvp")
    set {_levelNameBis} to configLang({_levelName}, {_player}, "language", true)
    make console execute command "/mvtp %{_player}'s name% %{_levelNameBis}%"
    wait 1 tick
    if {_message} is true:
        send title mineroomsGetLevel({_player}, {_level}) to {_player}
        send subtitle lang("minerooms.functions.travel.%{_level}%.name", {_player}) to {_player}
        set {_pvp} to "§2☻"
        if {_levelPvp} is "true":
            set {_pvp} to "§4☠"
            addPermission({_player}, "player.attack", true)
        else:
            removePermission({_player}, "player.attack", true)
        add "%{_levelDanger}%" to {_args::*}
        add {_pvp} to {_args::*}
        send actionbar superLang("minerooms.functions.travel.actionBar", {_player}, {_args::*}) to {_player}
        wait 1.5 seconds
        send title mineroomsGetLevel({_player}, {_level}) to {_player}
        send subtitle lang("minerooms.functions.travel.secure.%{_levelSecure}%", {_player}) to {_player}
        send actionbar superLang("minerooms.functions.travel.actionBar", {_player}, {_args::*}) to {_player}
        wait 1.5 seconds
        send title mineroomsGetLevel({_player}, {_level}) to {_player}
        send subtitle lang("minerooms.functions.travel.stable.%{_levelStable}%", {_player}) to {_player}
        send actionbar superLang("minerooms.functions.travel.actionBar", {_player}, {_args::*}) to {_player}
        wait 1.5 seconds
        send title mineroomsGetLevel({_player}, {_level}) to {_player}
        send subtitle lang("minerooms.functions.travel.entity.%{_levelEntity}%", {_player}) to {_player}
        send actionbar superLang("minerooms.functions.travel.actionBar", {_player}, {_args::*}) to {_player}
on chat:
    cancel event
    loop all players:
        set {_x} to loop-player
        if {_x}'s world is player's world:
            set {_mb} to mineroomsData("chat.message")
            set {_rank} to userData(player, "player.rank")
            set {_rankName} to lang("minerooms.ranks.%{_rank}%.name", loop-player)
            if "%{_rankName}%" is "<none>":
                set {_rankName} to ""
            
            
            if {_rankName} contain "§l":
                set {_cc::*} to {_rankName} split by "§"
                set {_rankColor} to "§%{_cc::2}%"
                set {_rankColor} to "%{_rankColor}%§l"
            else:
                set {_cc::*} to {_rankName} split by "§"
                set {_rankColor} to "§%{_cc::1}%"
            set {_mb} to "%{_mb}%"
            set {_c} to 0
            add {_rankColor} to {_args::*}
            add {_rankName} to {_args::*}
            add player's name to {_args::*}
            add message to {_args::*}
            loop {_args::*}:
                set {_v} to loop-value-2
                replace all "<arg%{_c}%>" with "%{_v}%" in {_mb}
                add 1 to {_c}
            send formatted {_mb} to loop-player
            send formatted "§6[§b%player's world%§6]§r %{_rankName}% %{_mb}%" to console
            clear {_args::*}
function mineroomsNoClip(player: player):
    set {_gui} to genericGui(lang("minerooms.command.noClip.gui.title", {_player}), 5, true)
    set slot 22 of {_gui} to redstone block named "§4Wait.."
    userData({_player}, "data.inv", "set", "manager.minerooms.noClip.main")
    open {_gui} to {_player}
    mineroomsNoClipGuiUpdater({_player})
function mineroomsNoClipGuiUpdater(player: player):
    set {_gui} to {_player}'s current inventory
    set slot 22 of {_gui} to air
    set {_sc} to 10
    set {_gc} to 0
    loop 24 times:
        if {_gc} is 10 or 19 or 28:
            add 7 to {_gc}
        else if {_gc} is 40:
            add 1 to {_gc}
        set slot {_gc} of {_gui} to yellow stained glass pane named "§l"
        add 1 to {_gc}
    loop yaml node keys "levels" from "bck.manager.minerooms.data":
        add loop-node to {_levelsList::*}
    loop {_levelsList::*}:
        if {_sc} = 17 or 27:
            add 2 to {_sc}
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_levelName} to mineroomsData("%loop-value%.name")
        set {_levelDanger} to mineroomsData("%loop-value%.survival_difficulty")
        set {_levelSecure} to mineroomsData("%loop-value%.secure")
        set {_levelStable} to mineroomsData("%loop-value%.stable")
        set {_levelEntity} to mineroomsData("%loop-value%.entity")
        set {_levelPvp} to mineroomsData("%loop-value%.pvp")
        set {_levelName} to configLang({_levelName}, {_player})
        if {_levelName} is not lang("minerooms.command.noClip.levels.-1", {_player}):
            if {_levelName} is "<none>":
                set {_levelName} to "??"
            replace all "_" with " " in {_levelName}
            set {_i} to paper named {_levelName}
            add {_levelDanger} to {_args::*}
            set line 2 of lore of {_i} to superLang("minerooms.command.noClip.gui.survival_difficulty", {_player}, {_args::*})
            clear {_args::*}
            if {_levelSecure} is "true":
                set {_levelSecure} to "§a✔"
            else:
                set {_levelSecure} to "§c✖"
            add {_levelSecure} to {_args::*}
            set line 3 of lore of {_i} to superLang("minerooms.command.noClip.gui.secure", {_player}, {_args::*})
            clear {_args::*}
            if "%{_levelStable}%" is "true":
                set {_levelStable} to "§a✔"
            else:
                set {_levelStable} to "§c✖"
            add {_levelStable} to {_args::*}
            set line 4 of lore of {_i} to superLang("minerooms.command.noClip.gui.stable", {_player}, {_args::*})
            clear {_args::*}
            add lang("minerooms.functions.travel.entity.%{_levelEntity}%", {_player}) to {_args::*}
            set line 5 of lore of {_i} to superLang("minerooms.command.noClip.gui.entity", {_player}, {_args::*})
            clear {_args::*}
            set {_pvp} to "§2☻"
            if {_levelPvp} is "true":
                set {_pvp} to "§4☠"
            add {_pvp} to {_args::*}
            set line 6 of lore of {_i} to superLang("minerooms.command.noClip.gui.pvp", {_player}, {_args::*})
            clear {_args::*}
            add {_levelName} to {_args::*}
            set line 8 of lore of {_i} to superLang("minerooms.command.noClip.gui.clickToTeleport", {_player}, {_args::*})
            set slot {_sc} of {_gui} to {_i}
            clear {_args::*}
            add 1 to {_sc}
    userData({_player}, "data.inv", "set", "manager.minerooms.noClip.main")
function mineroomsRankListGuiUpdater(player: player):
    set {_gui} to {_player}'s current inventory
    set slot 22 of {_gui} to air
    set {_sc} to 10
    set {_gc} to 0
    loop 24 times:
        if {_gc} is 10 or 19 or 28:
            add 7 to {_gc}
        else if {_gc} is 40:
            add 1 to {_gc}
        set slot {_gc} of {_gui} to yellow stained glass pane named "§l"
        add 1 to {_gc}
    loop yaml node keys "ranks" from "bck.manager.minerooms.data":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_rankName} to mineroomsData("%loop-value%.name")
        if {_rankName} is not set:
            set {_rankName} to "minerooms.ranks.%{_r}%.name"
        set {_perms::*} to yaml list "%loop-value%.perms" from "bck.manager.minerooms.data"
        if "%{_perms::*}%" is not "<none>":
            set {_rank.perms::*} to yaml list "%loop-value%.perms" from "bck.manager.minerooms.data"
        set {_i} to paper named configLang({_rankName}, {_player})
        set line 1 of lore of {_i} to lang("minerooms.command.ranks.list.gui.permissions", {_player})
        set {_rf} to 2
        loop {_rank.perms::*}:
            set {_x} to loop-value-2
            add "%{_x}%" to {_args::*}
            set line {_rf} of lore of {_i} to superLang("minerooms.command.ranks.list.gui.genericPermission", {_player}, {_args::*})
            add 1 to {_rf}
            clear {_args::*}
        set slot {_sc} of {_gui} to {_i}
        add 1 to {_sc}
        wait 1 tick
    userData({_player}, "data.inv", "set", "manager.minerooms.ranks.list.main")
on inventory click:
    if userData(player, "data.inv") is "false":
        stop
    if userData(player, "data.inv") is "manager.minerooms.noClip.main":
        cancel event
        set {_gui} to player's current inventory
        set {_i} to event-slot
        set {_t} to type of {_i}
        set {_n} to display name of {_i}
        set {_u} to {_n}
        set {_a} to item amount of event-slot
        if "%{_t}%" contain "barrier":
            if {_u} contain "Back":
                close player's inventory
        else:
            if "%{_t}%" contain "paper":
                loop yaml node keys "levels" from "bck.manager.minerooms.data":
                    add loop-node to {_levelsList::*}
                loop {_levelsList::*}:
                    if {_sc} = 17 or 27:
                        add 2 to {_sc}
                    set {_r} to loop-value
                    set {_r::*} to {_r} split by "."
                    set {_r} to {_r::2}
                    set {_levelName} to mineroomsData("%loop-value%.name")
                    set {_levelNameBis} to configLang({_levelName}, player, "language", true)
                    set {_levelName} to configLang({_levelName}, player)
                    replace all "_" with " " in {_levelName}
                    if {_u} is {_levelName}:
                        close player's inventory
                        set {_xx} to "%{_r}%" parsed as integer
                        mineroomsTravel(player, {_xx}, true)
                        #make console execute command "/mvtp %player's name% %{_levelNameBis}%"
    else if userData(player, "data.inv") is "manager.minerooms.ranks.list.main":
        cancel event
        set {_gui} to player's current inventory
        set {_i} to event-slot
        set {_t} to type of {_i}
        set {_n} to display name of {_i}
        set {_u} to {_n}
        set {_a} to item amount of event-slot
        if "%{_t}%" contain "barrier":
            if {_u} contain "Back":
                close player's inventory
function mineroomsGetLevel(player: player, num: integer=-1, def: boolean=false) :: text:
    set {_r} to configLang(mineroomsData("levels.%{_num}%.name"), {_player})
    if {_def} is false:
        replace all "_" with " " in {_r}
    return {_r}
#                                      mineroomsGetAllRanks functions                                                                          #
function mineroomsGetAllRanks() :: objects:
    loop yaml node keys "ranks" from "bck.manager.minerooms.data":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        add "%{_r}%" to {_return::*}
    return {_return::*}
#                                      mineroomsSetRank functions                                                                          #
function mineroomsSetRank(player: player, rank: text="wanderer", autoPerm: boolean=false):
    userData({_player}, "player.rank", "set", {_rank})
    set {_s} to selector({_player})
    superLog("§6[§4BCK§6/§eMineRooms§6]§r Rank of §7%{_s}% §rhas been set to §7%{_rank}%", "3")
    superLog("§6[§4BCK§6/§eMineRooms§6]§r Rank of §7%{_player}'s name% §rhas been set to §7%{_rank}%", "6", true)
    if {_autoPerm} is true:
        loop {server.permission.%{_player}'s name%.list::*}:
            if loop-value is not "server.owner":
                removePermission({_player}, loop-value, true)
        loop mineroomsGetRankPerms({_rank}):
            set {_x} to loop-value
            if "%{_x}%" contain "permissions":
                set {_data::*} to "%{_x}%" split by "."
                set {_w} to {_data::2}
                loop mineroomsGetRankPerms({_w}):
                    set {_xx} to loop-value-2
                    if {_xx} doesn't contain "permission":
                        addPermission({_player}, {_xx}, true)
            else:
                addPermission({_player}, {_x}, true)
#                                      mineroomsGetRank functions                                                                          #
function mineroomsGetRank(player: player) :: text:
    set {_r} to userData({_player}, "player.rank")
    return "%{_r}%"
#                                      mineroomsGetRankPerms functions                                                                          #
function mineroomsGetRankPerms(rank: text="?", player: text="?") :: objects:
    if {_rank} is "?":
        if {_player} is not "?":
            set {_player} to {_player} parsed as player
            set {_rank} to userData({_player}, "player.rank")
        set {_perms::*} to yaml list "ranks.%{_rank}%.perms" from "bck.manager.minerooms.data"
    else:
        set {_perms::*} to yaml list "ranks.%{_rank}%.perms" from "bck.manager.minerooms.data"
    return {_perms::*}
    
    set {_s} to selector({_player})
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_s}% §rhas been set to §7%{_rank}%", "4")
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_player}% §rhas been set to §7%{_rank}%", "6", true)
function mineroomsConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    return "%{_result}%"
function mineroomsConfigInteger(find: text, mode: text="extract", data: integer=0) :: integer:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    set {_result} to {_result} parsed as integer
    if {_result} is not set:
        set {_result} to 0
    return {_result}
function mineroomsConfigItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}

function mineroomsData(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    return "%{_result}%"
function mineroomsDataInteger(find: text, mode: text="extract", data: integer=0) :: integer:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    set {_result} to "%{_result}%" parsed as integer
    if {_result} is not set:
        set {_result} to 0
    return {_result}

function mineroomsDataBoolean(find: text, mode: text="extract", data: boolean=false) :: boolean:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    if {_result} is not set:
        set {_result} to false
    return {_result}
function mineroomsDataItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}
function mineroomsServerConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    return {_result}
function mineroomsServerConfigBoolean(find: text, mode: text="extract", data: boolean=false) :: boolean:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    if {_result} is not set:
        set {_result} to false
    return {_result}
function mineroomsServerConfigItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}
#                                      deleteAndDrop functions                                                                          #
function deleteAndDrop(player: player, location: location, dropItem: item):
    set {_fortune} to level of fortune of {_player}'s tool
    if {_fortune} is 1:
        set {_rng} to random integer between 1 and 2
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 2:
        set {_rng} to random integer between 1 and 3
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 3:
        set {_rng} to random integer between 1 and 4
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 4:
        set {_rng} to random integer between 2 and 5
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} is 5:
        set {_rng} to random integer between 2 and 6
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} > 5:
        set {_rng} to random integer between 5 and {_fortune}
        set {_r} to {_rng}
        set {_g} to {_r}
        set {_c} to {_g}
        if {_g} >= 65:
            set {_gg} to {_g} / 64
            set {_gg} to ceil({_gg})
            loop {_gg} times:
                if {_c} < 64:
                    drop {_c} of {_dropItem} at {_location}
                else:
                    drop 64 of {_dropItem} at {_location}
                remove 64 from {_c}
        else:
            drop {_g} of {_dropItem} at {_location}
        experienceDrop({_location}, 5, {_rng})
        #drop {_r} of {_dropItem} at {_location}
    else:
        drop {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
#                                      deleteAndDropMore functions                                                                          #
function deleteAndDropMore(player: player, location: location, dropItem: item, boosted: boolean=false):
    set {_fortune} to level of fortune of {_player}'s tool
    if {_fortune} is 1:
        set {_rng} to random integer between 3 and 8
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 2:
        set {_rng} to random integer between 4 and 12
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 3:
        set {_rng} to random integer between 5 and 18
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 4:
        set {_rng} to random integer between 7 and 25
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} is 5:
        set {_rng} to random integer between 15 and 34
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} > 5:
        set {_rng} to random integer between 15 and {_fortune}
        set {_r} to {_rng}
        set {_g} to {_r}
        set {_c} to {_g}
        if {_g} >= 65:
            set {_gg} to {_g} / 64
            set {_gg} to ceil({_gg})
            loop {_gg} times:
                if {_c} < 64:
                    drop {_c} of {_dropItem} at {_location}
                else:
                    drop 64 of {_dropItem} at {_location}
                remove 64 from {_c}
        else:
            drop {_g} of {_dropItem} at {_location}
        experienceDrop({_location}, 5, {_rng})
    else:
        set {_rng} to random integer between 3 and 5
        drop {_rng} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
#                                       deleteAndDropNoFortune function                                                                        #
function deleteAndDropNoFortune(player: player, location: location, dropItem: item):
    drop {_dropItem} at {_location}
#                                       experienceDrop function                                                                                 #
function experienceDrop(location: location, minxp: integer=1, maxxp: integer=3):
    set {_xp} to random number between {_minxp} and {_maxxp}
    spawn {_xp} of experience orb at {_location}
#                                       Inventory Saver functions                                                                         #
function mineroomsInventorySaver(player: player, drop: boolean=false):
    set {_s} to 0
    if {_helmet} is not set:
        set {_helmet} to air
    if {_chestplate} is not set:
        set {_chestplate} to air
    if {_leggings} is not set:
        set {_leggings} to air
    if {_boots} is not set:
        set {_boots} to air
    if {_off} is not set:
        set {_off} to air
    loop 36 times:
        set {_i} to slot {_s} of {_player}'s inventory
        set {_data::*} to "%{_i}%" split by " "
        set {_c} to {_data::1}
        set {_c} to {_c} parsed as integer
        if "%{_i}%" doesn't contain "0" or "1" or "2" or "3" or "4" or "5" or "6" or "7" or "8" or "9":
            set {_c} to 1
        set yaml value "inventory.%{_player}%.%{_s}%" from "bck.manager.minerooms.data" to {_i}
        if {_drop} is true:
            drop {_i} at {_player}'s location
        #broadcast "Item: %{_i}%/%{_s}%"
        add 1 to {_s}
    if {_drop} is true:
        drop {_player}'s helmet at {_player}'s location
        drop {_player}'s chestplate at {_player}'s location
        drop {_player}'s leggings at {_player}'s location
        drop {_player}'s boots at {_player}'s location
        drop offhand tool of {_player} at {_player}'s location
    set yaml value "inventory.%{_player}%.helmet" from "bck.manager.minerooms.data" to {_player}'s helmet
    set yaml value "inventory.%{_player}%.chestplate" from "bck.manager.minerooms.data" to {_player}'s chestplate
    set yaml value "inventory.%{_player}%.leggings" from "bck.manager.minerooms.data" to {_player}'s leggings
    set yaml value "inventory.%{_player}%.boots" from "bck.manager.minerooms.data" to {_player}'s boots
    set yaml value "inventory.%{_player}%.off_hand" from "bck.manager.minerooms.data" to offhand tool of {_player}
    set yaml value "inventory.%{_player}%.location" from "bck.manager.minerooms.data" to {_player}'s location
    save "bck.manager.minerooms.data"
function mineroomsShopAbbrevNumber(v: integer) :: text:
    if {_v} >= 1000:
        if {_v} < 1000000:
            set {_v} to "%{_v} / 1000%k"
        else:
            set {_v} to "%{_v} / 1000000%m"
    else:
        set {_v} to "%{_v}%"
    return {_v}