on load:
    if {skripts::*} contains "bck_minerooms.sk":
        send "§6[§4BCK§6]§r Loading minerooms..." to console
        wait 2 seconds
        send "§6[§4BCK§6/§eMineRooms§6]§r Loaded successfully !" to console
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/config.yml" as "bck.manager.minerooms.config"
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/data.yml" as "bck.manager.minerooms.data"
        mineroomsLoad()
    else:
        broadcast "§6[§4BCK§6/§eMineRooms§6]§r Script loading cancel It require (bck_minerooms.sk)"
        unload script file "bck_minerooms.sk"
    stop
#                                      txtGiver command                                                                          #
command /txtGiver [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_i} to arg-1 parsed as item
            give {_i} to player
on tab complete of "/txtGiver":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to all items
command /msk [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_a} to arg-1
            replace "minecraft:" with "" in {_a}
            set {_r} to convertMinecraftToSkriptString({_a})
            send "§6[§4BCK§6]§r §d%{_a}% §e-> §b%{_r}%"
command /skm [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_a} to arg-1
            set {_r} to convertSkriptToMinecraftString({_a}, true)
            send "§6[§4BCK§6]§r §d%{_a}% §e-> §b%{_r}%"
command /tg [<number=0>] [<number=10>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            kill player
            stop
        set {_c} to 0
        loop minecraftBaseItemsListItem():
            if {_c} < arg-2:
                if {_c} >= arg-1:
                    genericItemGive(player, loop-value)
                add 1 to {_c}
on tab complete of "/msk":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to minecraftBaseItemsList()
on tab complete of "/skm":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to all items
#                                      minerooms command                                                                          #
command /minerooms [<text>] [<text>] [<offlineplayer>] [<text>]:
    aliases: "mr"
    trigger:
        
#                                      mineroomsLoad functions                                                                          #
function mineroomsLoad():
    set {_data::*} to yaml list "data.minerooms.load.options" from "bck.manager.minerooms.config"
    if file "plugins/MineRooms/config.yml" doesn't exist:
        superLog("§6[§4BCK§6/§eMineRooms§6]§r §eInitialization..", "6.5")
        create script "plugins/MineRooms/config.yml"
        write "##                                                                                                                              " at line 1 to file "plugins/MineRooms/config.yml"
        write "##                   ,,                                                                                 " at line 2 to file "plugins/MineRooms/config.yml"
        write "## `7MMM.     ,MMF'  db                          `7MM""""Mq.                                             " at line 3 to file "plugins/MineRooms/config.yml"
        write "##   MMMb    dPMM                                  MM   `MM.                                            " at line 4 to file "plugins/MineRooms/config.yml"
        write "##   M YM   ,M MM  `7MM  `7MMpMMMb.  .gP""Ya        MM   ,M9  ,pW""Wq.   ,pW""Wq.`7MMpMMMb.pMMMb.  ,pP""Ybd " at line 5 to file "plugins/MineRooms/config.yml"
        write "##   M  Mb  M' MM    MM    MM    MM ,M'   Yb       MMmmdM9  6W'   `Wb 6W'   `Wb MM    MM    MM  8I   `"" " at line 6 to file "plugins/MineRooms/config.yml"
        write "##   M  YM.P'  MM    MM    MM    MM 8M""""""       MM  YM.  8M     M8 8M     M8 MM    MM    MM  `YMMMa. " at line 7 to file "plugins/MineRooms/config.yml"
        write "##   M  `YM'   MM    MM    MM    MM YM.    ,       MM   `Mb.YA.   ,A9 YA.   ,A9 MM    MM    MM  L.   I8 " at line 8 to file "plugins/MineRooms/config.yml"
        write "## .JML. `'  .JMML..JMML..JMML  JMML.`Mbmmd'     .JMML. .JMM.`Ybmd9'   `Ybmd9'.JMML  JMML  JMML.M9mmmP' " at line 9 to file "plugins/MineRooms/config.yml"
        write "" at line 10 to file "plugins/MineRooms/config.yml"
        write "##   ___           ___ _            _    _          _       _     _   " at line 11 to file "plugins/MineRooms/config.yml"
        write "##  / __\_   _    / __\ | __ _  ___| | _| | ___ __ (_) __ _| |__ | |_ " at line 12 to file "plugins/MineRooms/config.yml"
        write "## /__\// | | |  /__\// |/ _` |/ __| |/ / |/ / '_ \| |/ _` | '_ \| __|" at line 13 to file "plugins/MineRooms/config.yml"
        write "##/ \/  \ |_| | / \/  \ | (_| | (__|   <|   <| | | | | (_| | | | | |_ " at line 14 to file "plugins/MineRooms/config.yml"
        write "##\_____/\__, | \_____/_|\__,_|\___|_|\_\_|\_\_| |_|_|\__, |_| |_|\__|" at line 15 to file "plugins/MineRooms/config.yml"
        write "##       |___/                                        |___/           " at line 16 to file "plugins/MineRooms/config.yml"
        write "" at line 17 to file "plugins/MineRooms/config.yml"
        set {_x} to 18
        set {_c} to listCounter({_data::*})
        loop {_data::*}:
            write loop-value at line {_x} to file "plugins/MineRooms/config.yml"
            add 1 to {_x}
        wait 3 ticks
        superLog("§6[§4BCK§6/§eMineRooms§6]§r §eInitialization §nComplete§r§e !", "6.5")
    wait 10 ticks
    load yaml "plugins/MineRooms/config.yml" as "bck.server.minerooms.config"
    superLog("§6[§4BCK§6/§eMineRooms§6]§r §aLoaded file succeffully !", "6.5")
    wait 2 ticks
    
    loop yaml node keys "ranks" from "bck.server.minerooms.config":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_rankName} to mineroomsServerConfig("%loop-value%.name")
        if {_rankName} is not set:
            set {_rankName} to "minerooms.ranks.%{_r}%.name"
        set {_perms::*} to yaml list "%loop-value%.perms" from "bck.server.minerooms.config"
        if "%{_perms::*}%" is not "<none>":
            set {_rank.perms::*} to yaml list "%loop-value%.perms" from "bck.server.minerooms.config"
            set yaml list "%loop-value%.perms" from "bck.manager.minerooms.data" to {_rank.perms::*}
            mineroomsData("%loop-value%.name", "set", {_rankName})
            save "bck.manager.minerooms.data"
            clear {_rank.perms::*}
    wait 10 ticks
    superLog("§6[§4BCK§6/§eMineRooms§6]§r §eConfig has been §aupdated §e!", "6.5")

#                                      tab complete minerooms                                                                          #
on tab complete of "/minerooms" or "/mr":
    if hasPermission(player, "server.command.minerooms") is false:
        stop
    add "test" to {_data::*}
    if hasPermission(player, "op") is true:
        add "rank" to {_data::*}
    set tab completions for position 1 to {_data::*}
    if tab arg-1 is "rank":
        if hasPermission(player, "op") is true:
            clear {_data::*}
            add "set" to {_data::*}
            add "remove" to {_data::*}
            set tab completions for position 2 to {_data::*} 
            if tab arg-2 is "set":
                set tab completions for position 3 to all players
                if tab arg-3 is set:
                    set tab completions for position 4 to mineroomsGetAllRanks()
            else if tab arg-2 is "remove":
                set tab completions for position 3 to all players
                if tab arg-3 is set:
                    set tab completions for position 4 to userData(player, "player.rank")
on join:
    if mineroomsGetRank(player) is "<none>":
        mineroomsSetRank(player, "wanderer", true)
#                                      mineroomsGetAllRanks functions                                                                          #
function mineroomsGetAllRanks() :: objects:
    loop yaml node keys "ranks" from "bck.manager.minerooms.data":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        add "%{_r}%" to {_return::*}
    return {_return::*}
#                                      mineroomsSetRank functions                                                                          #
function mineroomsSetRank(player: player, rank: text="wanderer", autoPerm: boolean=false):
    userData({_player}, "player.rank", "set", {_rank})
    set {_s} to selector({_player})
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_s}% §rhas been set to §7%{_rank}%", "4")
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_player}% §rhas been set to §7%{_rank}%", "6", true)
    if {_autoPerm} is true:
        loop mineroomsGetRankPerms({_rank}):
            set {_x} to loop-value
            addPermission({_player}, {_x})
#                                      mineroomsGetRank functions                                                                          #
function mineroomsGetRank(player: player) :: text:
    set {_r} to userData({_player}, "player.rank")
    return "%{_r}%"
#                                      mineroomsSetRank functions                                                                          #
function mineroomsGetRankPerms(rank: text="?", player: text="?") :: objects:
    if {_rank} is not "?":
        if {_player} is not "?":
            set {_player} to {_player} parsed as player
            set {_rank} to userData({_player}, "player.rank")
        set {_perms::*} to yaml list "ranks.%{_rank}%.perms" from "bck.manager.minerooms.data"
    else:
        set {_perms::*} to yaml list "ranks.%{_rank}%.perms" from "bck.manager.minerooms.data"
    return {_perms::*}
    
    set {_s} to selector({_player})
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_s}% §rhas been set to §7%{_rank}%", "4")
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_player}% §rhas been set to §7%{_rank}%", "6", true)
function mineroomsConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    return "%{_result}%"
function mineroomsConfigInteger(find: text, mode: text="extract", data: integer=0) :: integer:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    set {_result} to {_result} parsed as integer
    if {_result} is not set:
        set {_result} to 0
    return {_result}
function mineroomsConfigItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}

function mineroomsData(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    return "%{_result}%"
function mineroomsDataInteger(find: text, mode: text="extract", data: integer=0) :: integer:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    set {_result} to "%{_result}%" parsed as integer
    if {_result} is not set:
        set {_result} to 0
    return {_result}

function mineroomsDataBoolean(find: text, mode: text="extract", data: boolean=false) :: boolean:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    if {_result} is not set:
        set {_result} to false
    return {_result}
function mineroomsDataItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}
function mineroomsServerConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    return {_result}
function mineroomsServerConfigBoolean(find: text, mode: text="extract", data: boolean=false) :: boolean:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    if {_result} is not set:
        set {_result} to false
    return {_result}
function mineroomsServerConfigItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}
#                                      deleteAndDrop functions                                                                          #
function deleteAndDrop(player: player, location: location, dropItem: item):
    set {_fortune} to level of fortune of {_player}'s tool
    if {_fortune} is 1:
        set {_rng} to random integer between 1 and 2
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 2:
        set {_rng} to random integer between 1 and 3
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 3:
        set {_rng} to random integer between 1 and 4
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 4:
        set {_rng} to random integer between 2 and 5
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} is 5:
        set {_rng} to random integer between 2 and 6
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} > 5:
        set {_rng} to random integer between 5 and {_fortune}
        set {_r} to {_rng}
        set {_g} to {_r}
        set {_c} to {_g}
        if {_g} >= 65:
            set {_gg} to {_g} / 64
            set {_gg} to ceil({_gg})
            loop {_gg} times:
                if {_c} < 64:
                    drop {_c} of {_dropItem} at {_location}
                else:
                    drop 64 of {_dropItem} at {_location}
                remove 64 from {_c}
        else:
            drop {_g} of {_dropItem} at {_location}
        experienceDrop({_location}, 5, {_rng})
        #drop {_r} of {_dropItem} at {_location}
    else:
        drop {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
#                                      deleteAndDropMore functions                                                                          #
function deleteAndDropMore(player: player, location: location, dropItem: item, boosted: boolean=false):
    set {_fortune} to level of fortune of {_player}'s tool
    if {_fortune} is 1:
        set {_rng} to random integer between 3 and 8
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 2:
        set {_rng} to random integer between 4 and 12
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 3:
        set {_rng} to random integer between 5 and 18
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 4:
        set {_rng} to random integer between 7 and 25
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} is 5:
        set {_rng} to random integer between 15 and 34
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} > 5:
        set {_rng} to random integer between 15 and {_fortune}
        set {_r} to {_rng}
        set {_g} to {_r}
        set {_c} to {_g}
        if {_g} >= 65:
            set {_gg} to {_g} / 64
            set {_gg} to ceil({_gg})
            loop {_gg} times:
                if {_c} < 64:
                    drop {_c} of {_dropItem} at {_location}
                else:
                    drop 64 of {_dropItem} at {_location}
                remove 64 from {_c}
        else:
            drop {_g} of {_dropItem} at {_location}
        experienceDrop({_location}, 5, {_rng})
    else:
        set {_rng} to random integer between 3 and 5
        drop {_rng} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
#                                       deleteAndDropNoFortune function                                                                        #
function deleteAndDropNoFortune(player: player, location: location, dropItem: item):
    drop {_dropItem} at {_location}
#                                       experienceDrop function                                                                                 #
function experienceDrop(location: location, minxp: integer=1, maxxp: integer=3):
    set {_xp} to random number between {_minxp} and {_maxxp}
    spawn {_xp} of experience orb at {_location}
#                                       Inventory Saver functions                                                                         #
function mineroomsInventorySaver(player: player, drop: boolean=false):
    set {_s} to 0
    if {_helmet} is not set:
        set {_helmet} to air
    if {_chestplate} is not set:
        set {_chestplate} to air
    if {_leggings} is not set:
        set {_leggings} to air
    if {_boots} is not set:
        set {_boots} to air
    if {_off} is not set:
        set {_off} to air
    loop 36 times:
        set {_i} to slot {_s} of {_player}'s inventory
        set {_data::*} to "%{_i}%" split by " "
        set {_c} to {_data::1}
        set {_c} to {_c} parsed as integer
        if "%{_i}%" doesn't contain "0" or "1" or "2" or "3" or "4" or "5" or "6" or "7" or "8" or "9":
            set {_c} to 1
        set yaml value "inventory.%{_player}%.%{_s}%" from "bck.manager.minerooms.data" to {_i}
        if {_drop} is true:
            drop {_i} at {_player}'s location
        #broadcast "Item: %{_i}%/%{_s}%"
        add 1 to {_s}
    if {_drop} is true:
        drop {_player}'s helmet at {_player}'s location
        drop {_player}'s chestplate at {_player}'s location
        drop {_player}'s leggings at {_player}'s location
        drop {_player}'s boots at {_player}'s location
        drop offhand tool of {_player} at {_player}'s location
    set yaml value "inventory.%{_player}%.helmet" from "bck.manager.minerooms.data" to {_player}'s helmet
    set yaml value "inventory.%{_player}%.chestplate" from "bck.manager.minerooms.data" to {_player}'s chestplate
    set yaml value "inventory.%{_player}%.leggings" from "bck.manager.minerooms.data" to {_player}'s leggings
    set yaml value "inventory.%{_player}%.boots" from "bck.manager.minerooms.data" to {_player}'s boots
    set yaml value "inventory.%{_player}%.off_hand" from "bck.manager.minerooms.data" to offhand tool of {_player}
    set yaml value "inventory.%{_player}%.location" from "bck.manager.minerooms.data" to {_player}'s location
    save "bck.manager.minerooms.data"
function mineroomsShopAbbrevNumber(v: integer) :: text:
    if {_v} >= 1000:
        if {_v} < 1000000:
            set {_v} to "%{_v} / 1000%k"
        else:
            set {_v} to "%{_v} / 1000000%m"
    else:
        set {_v} to "%{_v}%"
    return {_v}