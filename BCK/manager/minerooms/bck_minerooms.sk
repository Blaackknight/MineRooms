on load:
    if {skripts::*} contains "bck_minerooms.sk":
        send "§6[§4BCK§6]§r Loading minerooms..." to console
        wait 2 seconds
        send "§6[§4BCK§6/§eMineRooms§6]§r Loaded successfully !" to console
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/config.yml" as "bck.manager.minerooms.config"
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/data.yml" as "bck.manager.minerooms.data"
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/bdd.yml" as "bck.manager.minerooms.bdd"
        mineroomsLoad()
        add "default" to {mr.chats::*}
        add "all" to {mr.chats::*}
        add "meg" to {mr.chats::*}
        add "staff" to {mr.chats::*}
        add mineroomsGetLevels(true) to {mr.chats::*}
    else:
        broadcast "§6[§4BCK§6/§eMineRooms§6]§r Script loading cancel It require (bck_minerooms.sk)"
        unload script file "bck_minerooms.sk"
    stop
on unload:
    clear {mr.chats::*}
#                                      txtGiver command                                                                          #
command /txtGiver [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_i} to arg-1 parsed as item
            give {_i} to player
on tab complete of "/txtGiver":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to all items
command /msk [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_a} to arg-1
            replace "minecraft:" with "" in {_a}
            set {_r} to convertMinecraftToSkriptString({_a})
            send "§6[§4BCK§6]§r §d%{_a}% §e-> §b%{_r}%"
command /skm [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_a} to arg-1
            set {_r} to convertSkriptToMinecraftString({_a}, true)
            send "§6[§4BCK§6]§r §d%{_a}% §e-> §b%{_r}%"
command /tg [<number=0>] [<number=10>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            kill player
            stop
        set {_c} to 0
        loop minecraftBaseItemsListItem():
            if {_c} < arg-2:
                if {_c} >= arg-1:
                    genericItemGive(player, loop-value)
                add 1 to {_c}
on tab complete of "/msk":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to minecraftBaseItemsList()
on tab complete of "/skm":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to all items
#                                      minerooms command                                                                          #
command /minerooms [<text>] [<text>] [<offlineplayer>] [<text>]:
    aliases: /mr
    trigger:
        if arg-1 is not set:
            add command to {_args::*}
            send formatted superLang("minerooms.command.noOption", player, {_args::*}) to player
        if arg-1 is "rank":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            if arg-2 is not set:
                add command to {_args::*}
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.noSecondOption", player, {_args::*}) to player
            else if arg-2 is "set":
                if arg-3 is not set:
                    send formatted lang("minerooms.command.missingPlayer", player) to player
                else:
                    if arg-4 is not set:
                        send formatted lang("minerooms.command.missingRank", player) to player
                    else:
                        if mineroomsGetAllRanks() doesn't contain arg-4:
                            add arg-4 to {_args::*}
                            send formatted superLang("minerooms.command.unknownRank", player, {_args::*}) to player
                        else:
                            mineroomsSetRank(arg-3, arg-4, true)
            else if arg-2 is "remove":
                if arg-3 is not set:
                    send formatted lang("minerooms.command.missingPlayer", player) to player
                else:
                    if arg-4 is not set:
                        send formatted lang("minerooms.command.missingRank", player) to player
                    else:
                        if mineroomsGetAllRanks() doesn't contain arg-4:
                            add arg-4 to {_args::*}
                            send formatted superLang("minerooms.command.unknownRank", player, {_args::*}) to player
                        else:
                            if userData(arg-3, "player.rank") is arg-4:
                                mineroomsSetRank(arg-3, "default", true)
                            else:
                                add arg-3's name to {_args::*}
                                send formatted superLang("minerooms.command.hisDontHaveThisRank", player, {_args::*}) to player
            else if arg-2 is "list":
                set {_gui} to genericGui(lang("minerooms.command.ranks.list.gui.title", player), 5, true)
                set slot 22 of {_gui} to redstone block named "§4Wait.."
                userData(player, "data.inv", "set", "manager.minerooms.ranks.list.main")
                open {_gui} to player
                mineroomsRankListGuiUpdater(player)
            else:
                add arg-2 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
        else if arg-1 is "noclip":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            mineroomsNoClip(player)
        else if arg-1 is "lore":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            if arg-2 is not set:
                send formatted lang("minerooms.command.lore.translationKeyMissing", player) to player
                stop
            set {_i} to player's tool
            if {_i} is air:
                send formatted lang("minerooms.command.lore.handIsEmpty", player) to player
                stop
            set line 2 of lore of player's tool to "§d<lang:minerooms.levels.%arg-2%>"
            send formatted lang("minerooms.command.lore.success", player) to player
        else if arg-1 is "restock":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            set {_i} to player's tool
            if {_i} is air:
                send formatted lang("minerooms.command.restock.handIsEmpty", player) to player
                stop
            if arg-2 is not set:
                set {_res} to "default"
            else:
                if mineroomsGetRestocks() doesn't contain arg-2:
                    add arg-2 to {_args::*}
                    send formatted superLang("minerooms.command.restock.unknownRestock", player, {_args::*}) to players
                    stop
                set {_res} to arg-2
            set line 2 of lore of player's tool to "§b<restock:%{_res}%>"
            send formatted lang("minerooms.command.restock.success", player) to player
        else if arg-1 is "coordinate":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            if arg-2 is not set:
                send formatted lang("minerooms.command.coordinate.translationKeyMissing", player) to player
                stop
            set {_data::*} to arg-2 split by "_"
            set {_x} to {_data::1}
            set {_y} to {_data::2}
            set {_z} to {_data::3}
            set {_i} to player's tool
            if {_i} is air:
                send formatted lang("minerooms.command.coordinate.handIsEmpty", player) to player
                stop
            set line 2 of lore of player's tool to "§a<coordinate:%{_x}%_%{_y}%_%{_z}%>"
            send formatted lang("minerooms.command.coordinate.success", player) to player
        else if arg-1 is "travel":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            set {_i} to player's tool
            if {_i} is air:
                send formatted lang("minerooms.command.travel.handIsEmpty", player) to player
                stop
            if arg-2 is not set:
                set {_res} to "default"
            else:
                if mineroomsGetLevels(true) doesn't contain arg-2:
                    add arg-2 to {_args::*}
                    send formatted superLang("minerooms.command.travel.unknownLevel", player, {_args::*}) to player
                    stop
                set {_res} to arg-2
            set line 2 of lore of player's tool to "§b<travel:%{_res}%>"
            send formatted lang("minerooms.command.travel.success", player) to player
        else if arg-1 is "wiki":
            if player cannot hold 1 written book:
                send formatted lang("minerooms.command.wiki.noEnoughPlace", player) to player
                stop
            set {_x} to userData(player, "data.language")
            if "%{_x}%" is "<none>":
                set {_x} to languageConfig("data.defaultLanguage")
                userData(player, "data.language", "set", {_x})
            load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
            set {_pages::*} to yaml list "minerooms.wiki.book.pages" from "bck.manager.language.%{_x}%"
            set {_name} to lang("minerooms.wiki.book.name", player)
            set {_a} to lang("minerooms.wiki.book.author", player)
            set {_w} to ""
            if listCounter({_pages::*}) is 1:
                set {_w} to "'{""text"":""%{_v}%""}'"
            loop {_pages::*}:
                set {_v} to loop-value
                replace all "<player>" with player's name in {_v}
                replace all "<uuid>" with player's uuid in {_v}
                replace all "<name>" with {_name} in {_v}
                replace all "<author>" with {_a} in {_v}
                if loop-index is "1":
                    set {_w} to "'{""text"":""%{_v}%""}'"
                else:
                    set {_w} to "%{_w}%,'{""text"":""%{_v}%""}'"
            set {_cmd} to "/give %player's name% written_book{pages:[%{_w}%],title:""%{_name}%"",author:""%{_a}%""}"
            make console execute command {_cmd}
            wait 1 tick
            set {_ss} to 0
            loop 36 times:
                set {_i} to slot {_ss} of player's inventory
                if "%{_i}%" is "written book":
                    open book {_i} to player
                    set slot {_ss} of player's inventory to air
                    exit loop
                add 1 to {_ss}
        else if arg-1 is "chat":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            if arg-2 is not set:
                send formatted lang("minerooms.command.chat.missingOption", player) to player
                stop
            if "%{mr.chats::*}%" doesn't contain arg-2:
                add arg-2 to {_args::*}
                send formatted superLang("minerooms.command.chat.unknownOption", player, {_args::*}) to player
                stop
            else:
                userData(player, "player.chat", "set", arg-2)
                add arg-2 to {_args::*}
                send formatted superLang("minerooms.command.chat.success", player, {_args::*}) to player
        else if arg-1 is "manage":
            set {_v} to arg-2 parsed as offlineplayer
            if all players doesn't contain {_v}:
                send formatted commandError(command, "%arg-1% %arg-2%", player) to player
            else:
                userData(player, "data.temp.manage", "set", "%{_v}%")
                mineroomsManageGuiMain(player)
        else if arg-1 is "vanish":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            mineroomsVanish(player)
        else if arg-1 is "invsee":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            set {_v} to arg-2 parsed as offlineplayer
            if all players doesn't contain {_v}:
                send formatted commandError(command, "%arg-1% %arg-2%", player) to player
            else:
                mineroomsInvSee(player, {_v}, true)
        else if arg-1 is "endersee":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            set {_v} to arg-2 parsed as offlineplayer
            if all players doesn't contain {_v}:
                send formatted commandError(command, "%arg-1% %arg-2%", player) to player
            else:
                mineroomsEnderSee(player, {_v}, true)
        else if arg-1 is "freeze":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            set {_v} to arg-2 parsed as offlineplayer
            if all players doesn't contain {_v}:
                send formatted commandError(command, "%arg-1% %arg-2%", player) to player
            else:
                mineroomsFreeze({_v}, player)
        else if arg-1 is "rlc":
            if hasPermission(player, "server.owner") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            send formatted superLang("minerooms.command.rlc.deletingFile", player, {_args::*}) to player
            delete script "plugins/MineRooms/config.yml"
            wait 1 second
            send formatted superLang("minerooms.command.rlc.creatingFile", player, {_args::*}) to player
            wait 1 second
            mineroomsLoad()
        else:
            add arg-1 to {_args::*}
            send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
#                                      mineroomsLoad functions                                                                          #
function mineroomsLoad():
    set {_data::*} to yaml list "data.minerooms.load.options" from "bck.manager.minerooms.config"
    if file "plugins/MineRooms/config.yml" doesn't exist:
        superLog("§6[§4BCK§6/§eMineRooms§6]§r §eInitialization..", "6.")
        create script "plugins/MineRooms/config.yml"
        write "##                                                                                                                              " at line 1 to file "plugins/MineRooms/config.yml"
        write "##                   ,,                                                                                 " at line 2 to file "plugins/MineRooms/config.yml"
        write "## `7MMM.     ,MMF'  db                          `7MM""""Mq.                                             " at line 3 to file "plugins/MineRooms/config.yml"
        write "##   MMMb    dPMM                                  MM   `MM.                                            " at line 4 to file "plugins/MineRooms/config.yml"
        write "##   M YM   ,M MM  `7MM  `7MMpMMMb.  .gP""Ya        MM   ,M9  ,pW""Wq.   ,pW""Wq.`7MMpMMMb.pMMMb.  ,pP""Ybd " at line 5 to file "plugins/MineRooms/config.yml"
        write "##   M  Mb  M' MM    MM    MM    MM ,M'   Yb       MMmmdM9  6W'   `Wb 6W'   `Wb MM    MM    MM  8I   `"" " at line 6 to file "plugins/MineRooms/config.yml"
        write "##   M  YM.P'  MM    MM    MM    MM 8M""""""       MM  YM.  8M     M8 8M     M8 MM    MM    MM  `YMMMa. " at line 7 to file "plugins/MineRooms/config.yml"
        write "##   M  `YM'   MM    MM    MM    MM YM.    ,       MM   `Mb.YA.   ,A9 YA.   ,A9 MM    MM    MM  L.   I8 " at line 8 to file "plugins/MineRooms/config.yml"
        write "## .JML. `'  .JMML..JMML..JMML  JMML.`Mbmmd'     .JMML. .JMM.`Ybmd9'   `Ybmd9'.JMML  JMML  JMML.M9mmmP' " at line 9 to file "plugins/MineRooms/config.yml"
        write "" at line 10 to file "plugins/MineRooms/config.yml"
        write "##   ___           ___ _            _    _          _       _     _   " at line 11 to file "plugins/MineRooms/config.yml"
        write "##  / __\_   _    / __\ | __ _  ___| | _| | ___ __ (_) __ _| |__ | |_ " at line 12 to file "plugins/MineRooms/config.yml"
        write "## /__\// | | |  /__\// |/ _` |/ __| |/ / |/ / '_ \| |/ _` | '_ \| __|" at line 13 to file "plugins/MineRooms/config.yml"
        write "##/ \/  \ |_| | / \/  \ | (_| | (__|   <|   <| | | | | (_| | | | | |_ " at line 14 to file "plugins/MineRooms/config.yml"
        write "##\_____/\__, | \_____/_|\__,_|\___|_|\_\_|\_\_| |_|_|\__, |_| |_|\__|" at line 15 to file "plugins/MineRooms/config.yml"
        write "##       |___/                                        |___/           " at line 16 to file "plugins/MineRooms/config.yml"
        write "" at line 17 to file "plugins/MineRooms/config.yml"
        set {_x} to 18
        set {_c} to listCounter({_data::*})
        loop {_data::*}:
            write loop-value at line {_x} to file "plugins/MineRooms/config.yml"
            add 1 to {_x}
        wait 3 ticks
        superLog("§6[§4BCK§6/§eMineRooms§6]§r §eInitialization §nComplete§r§e !", "6.4")
    wait 3 ticks
    load yaml "plugins/MineRooms/config.yml" as "bck.server.minerooms.config"
    superLog("§6[§4BCK§6/§eMineRooms§6]§r §aLoaded file succeffully !", "6.4")
    wait 2 ticks

    mineroomsData("chat.message", "set", mineroomsServerConfig("chat.message"))
    mineroomsData("chat.levelMessage", "set", mineroomsServerConfig("chat.levelMessage"))
    mineroomsData("chat.megMessage", "set", mineroomsServerConfig("chat.megMessage"))
    mineroomsData("chat.staffMessage", "set", mineroomsServerConfig("chat.staffMessage"))

    mineroomsData("decoCombat.time", "set", mineroomsServerConfig("decoCombat.time"))

    loop yaml node keys "levels" from "bck.server.minerooms.config":
        add loop-node to {_levelsList::*}
    loop {_levelsList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        if "%{_r::3}%" is not "<none>":
            set {_r} to "%{_r::2}%-%{_r::3}%"
        set {_levelName} to mineroomsServerConfig("levels.%{_r}%.name")
        set {_levelDanger} to yaml value "%loop-value%.survival_difficulty" from "bck.server.minerooms.config"
        set {_levelSecure} to yaml value "%loop-value%.secure" from "bck.server.minerooms.config"
        set {_levelStable} to yaml value "%loop-value%.stable" from "bck.server.minerooms.config"
        set {_levelEntity} to yaml value "%loop-value%.entity" from "bck.server.minerooms.config"
        set {_levelPvp} to yaml value "%loop-value%.pvp" from "bck.server.minerooms.config"
        set {_levelOpenDoor} to yaml value "%loop-value%.openDoor" from "bck.server.minerooms.config"
        set {_levelOpenTrapDoor} to yaml value "%loop-value%.openTrapDoor" from "bck.server.minerooms.config"
        set {_levelBreakItemFrame} to yaml value "%loop-value%.breakItemFrame" from "bck.server.minerooms.config"
        set {_levelBreakArmorStand} to yaml value "%loop-value%.breakArmorStand" from "bck.server.minerooms.config"
        set {_levelBreakPainting} to yaml value "%loop-value%.breakPainting" from "bck.server.minerooms.config"
        set {_levelGrabFlowerPot} to yaml value "%loop-value%.grabFlowerPot" from "bck.server.minerooms.config"
        set {_levelEditSign} to yaml value "%loop-value%.editSign" from "bck.server.minerooms.config"
        set {_levelDropItem} to yaml value "%loop-value%.dropItem" from "bck.server.minerooms.config"
        set {_levelFallDamage} to yaml value "%loop-value%.fallDamage" from "bck.server.minerooms.config"
        set {_levelDecoCombat} to yaml value "%loop-value%.decoCombat" from "bck.server.minerooms.config"
        set {_levelEffectType} to yaml value "%loop-value%.effect.type" from "bck.server.minerooms.config"
        set {_levelEffectEffects::*} to yaml list "%loop-value%.effect.effects" from "bck.server.minerooms.config"
        set {_levelMobSpawnAlloy::*} to yaml list "%loop-value%.mobSpawn.alloy" from "bck.server.minerooms.config"
        if "%{_levelName}%" is "<none>":
            set {_levelName} to "??"
        if "%{_levelDanger}%" is "<none>":
            set {_levelDanger} to "0"
        if "%{_levelSecure}%" is "<none>":
            set {_levelSecure} to "false"
        if "%{_levelStable}%" is "<none>":
            set {_levelStable} to "false"
        if "%{_levelEntity}%" is "<none>":
            set {_levelEntity} to "0"
        if "%{_levelPvp}%" is "<none>":
            set {_levelPvp} to "false"
        if "%{_levelOpenDoor}%" is "<none>":
            set {_levelOpenDoor} to "false"
        if "%{_levelOpenTrapDoor}%" is "<none>":
            set {_levelOpenTrapDoor} to "false"
        if "%{_levelBreakItemFrame}%" is "<none>":
            set {_levelBreakItemFrame} to "false"
        if "%{_levelBreakArmorStand}%" is "<none>":
            set {_levelBreakArmorStand} to "false"
        if "%{_levelBreakPainting}%" is "<none>":
            set {_levelBreakPainting} to "false"
        if "%{_levelGrabFlowerPot}%" is "<none>":
            set {_levelGrabFlowerPot} to "false"
        if "%{_levelEditSign}%" is "<none>":
            set {_levelEditSign} to "false"
        if "%{_levelDropItem}%" is "<none>":
            set {_levelDropItem} to "false"
        if "%{_levelFallDamage}%" is "<none>":
            set {_levelFallDamage} to "false"
        if "%{_levelDecoCombat}%" is "<none>":
            set {_levelDecoCombat} to "false"
        if "%{_levelEffectType}%" is "<none>":
            set {_levelEffectType} to "1"
        mineroomsData("%loop-value%.name", "set", "%{_levelName}%")
        mineroomsData("%loop-value%.survival_difficulty", "set", "%{_levelDanger}%")
        mineroomsData("%loop-value%.secure", "set", "%{_levelSecure}%")
        mineroomsData("%loop-value%.stable", "set", "%{_levelStable}%")
        mineroomsData("%loop-value%.entity", "set", "%{_levelEntity}%")
        mineroomsData("%loop-value%.pvp", "set", "%{_levelPvp}%")
        mineroomsData("%loop-value%.openDoor", "set", "%{_levelOpenDoor}%")
        mineroomsData("%loop-value%.openTrapDoor", "set", "%{_levelOpenTrapDoor}%")
        mineroomsData("%loop-value%.breakItemFrame", "set", "%{_levelBreakItemFrame}%")
        mineroomsData("%loop-value%.breakArmorStand", "set", "%{_levelBreakArmorStand}%")
        mineroomsData("%loop-value%.breakPainting", "set", "%{_levelBreakPainting}%")
        mineroomsData("%loop-value%.grabFlowerPot", "set", "%{_levelBreakPainting}%")
        mineroomsData("%loop-value%.editSign", "set", "%{_levelEditSign}%")
        mineroomsData("%loop-value%.dropItem", "set", "%{_levelDropItem}%")
        mineroomsData("%loop-value%.fallDamage", "set", "%{_levelFallDamage}%")
        mineroomsData("%loop-value%.decoCombat", "set", "%{_levelDecoCombat}%")
        mineroomsData("%loop-value%.effect.type", "set", "%{_levelEffectType}%")
        set yaml list "%loop-value%.effect.effects" from "bck.manager.minerooms.data" to  {_levelEffectEffects::*}
        set yaml list "%loop-value%.mobSpawn.allow" from "bck.manager.minerooms.data" to  {_levelMobSpawnAlloy::*}
        save "bck.manager.minerooms.data"
    
    loop yaml node keys "restock" from "bck.server.minerooms.config":
        add loop-node to {_restockList::*}
    loop {_restockList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        loop yaml node keys "restock.%{_r}%" from "bck.server.minerooms.config":
            add loop-node to {_dataList::*}
        loop {_dataList::*}:
            set {_i} to loop-value-2
            set {_ii} to loop-value-2
            set {_i::*} to {_i} split by "."
            set {_i} to {_i::3}
            replace all "_" with " " in {_i}
            
            set {_restockMin} to yaml value "%{_ii}%.min" from "bck.server.minerooms.config" 
            set {_restockMax} to yaml value "%{_ii}%.max" from "bck.server.minerooms.config" 
            set {_restockChance} to yaml value "%{_ii}%.chance" from "bck.server.minerooms.config"
            set {_restockMin} to "%{_restockMin}%" parsed as integer
            set {_restockMax} to "%{_restockMax}%" parsed as integer
            set {_restockChance} to "%{_restockChance}%" parsed as integer
            set {_restockCustomName} to mineroomsServerConfig("%{_ii}%.custom.name")
            set {_restockCustomLores::*} to yaml list "%{_ii}%.custom.lores" from "bck.server.minerooms.config"
            if "%{_restockMin}%" is "<none>":
                set {_restockMin} to 0
            if "%{_restockMax}%" is "<none>":
                set {_restockMin} to 1
            if "%{_restockChance}%" is "<none>":
                set {_restockChance} to 100
            mineroomsData("%{_ii}%.min", "set", "%{_restockMin}%")
            mineroomsData("%{_ii}%.max", "set", "%{_restockMax}%")
            mineroomsData("%{_ii}%.chance", "set", "%{_restockChance}%")
            if {_restockCustomName} is set:
                mineroomsData("%{_ii}%.custom.name", "set", {_restockCustomName})
            if {_restockCustomLores::*} is set:
                set yaml list "%{_ii}%.custom.lores" from "bck.manager.minerooms.data" to {_restockCustomLores::*}
                save "bck.manager.minerooms.data"

    loop yaml node keys "ranks" from "bck.server.minerooms.config":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_rankName} to mineroomsServerConfig("%loop-value%.name")
        if {_rankName} is not set:
            set {_rankName} to "minerooms.ranks.%{_r}%.name"
        set {_perms::*} to yaml list "%loop-value%.perms" from "bck.server.minerooms.config"
        if "%{_perms::*}%" is not "<none>":
            set {_rank.perms::*} to yaml list "%loop-value%.perms" from "bck.server.minerooms.config"
            mineroomsData("%loop-value%.name", "set", {_rankName})
            set yaml list "%loop-value%.perms" from "bck.manager.minerooms.data" to {_rank.perms::*}
            save "bck.manager.minerooms.data"
            clear {_rank.perms::*}

    loop yaml node keys "rules" from "bck.server.minerooms.config":
        add loop-node to {_rulesList::*}
    loop {_rulesList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_st} to mineroomsServerConfig("%loop-value%.status")
        coreDataBoolean("%{_r}%.status", "set", {_st})
    wait 5 ticks
    superLog("§6[§4BCK§6/§eMineRooms§6]§r §eConfig has been §aupdated §e!", "6.4")

#                                      tab complete minerooms                                                                          #
on tab complete of "/minerooms" or "/mr":
    if hasPermission(player, "server.command.minerooms") is false:
        stop
    if hasPermission(player, "op") is true:
        add "rank" to {_data::*}
        add "noclip" to {_data::*}
        add "lore" to {_data::*}
        add "restock" to {_data::*}
        add "coordinate" to {_data::*}
        add "travel" to {_data::*}
        add "manage" to {_data::*}
        add "vanish" to {_data::*}
        add "invsee" to {_data::*}
        add "endersee" to {_data::*}
        add "freeze" to {_data::*}
        add "rlc" to {_data::*}
    add "wiki" to {_data::*}
    add "chat" to {_data::*}
    set tab completions for position 1 to {_data::*}
    if tab arg-1 is "rank":
        if hasPermission(player, "op") is true:
            clear {_data::*}
            add "set" to {_data::*}
            add "remove" to {_data::*}
            add "list" to {_data::*}
            set tab completions for position 2 to {_data::*} 
            if tab arg-2 is "set":
                set tab completions for position 3 to all players
                if tab arg-3 is set:
                    set tab completions for position 4 to mineroomsGetAllRanks()
            else if tab arg-2 is "remove":
                set tab completions for position 3 to all players
                if tab arg-3 is set:
                    set tab completions for position 4 to userData(player, "player.rank")
    else if tab arg-1 is "lore":
        if hasPermission(player, "op") is true:

    else if tab arg-1 is "restock":
        if hasPermission(player, "op") is true:
            loop yaml node keys "restock" from "bck.manager.minerooms.data":
                add loop-node to {_dataList::*}
            loop {_dataList::*}:
                set {_x::*} to loop-value split by "."
                add {_x::2} to {_args::*}
            set tab completions for position 2 to {_args::*}
    else if tab arg-1 is "coordinate":
        if hasPermission(player, "op") is true:
            
    else if tab arg-1 is "travel":
        if hasPermission(player, "op") is true:
            set tab completions for position 2 to mineroomsGetLevels(true)
    else if tab arg-1 is "chat":
        if hasPermission(player, "op") is true:
            set tab completions for position 2 to {mr.chats::*}
        else if mineroomsGetRank(player) is "meg_member":
            set tab completions for position 2 to "default" and "meg"
    else if tab arg-1 is "manage":
        set tab completions for position 2 to all players
    else if tab arg-1 is "invsee":
        set tab completions for position 2 to all players
    else if tab arg-1 is "endersee":
        set tab completions for position 2 to all players
    else if tab arg-1 is "freeze":
        set tab completions for position 2 to all players
function mineroomsManageGuiMain(player: player):
    set {_x} to userData({_player}, "data.temp.manage")
    set {_x} to {_x} parsed as offline player
    loadUserData({_x})
    set {_gui} to genericGui("§7%{_x}'s name%", 5, true)
    set slot 22 of {_gui} to redstone block named "§4Wait.."
    userData({_player}, "data.inv", "set", "manager.minerooms.manage.main")
    open {_gui} to {_player}
    set slot 22 of {_gui} to air
    set {_tp} to ender pearl named lang("minerooms.manage.view.tp", {_player})
    set {_inv} to chest named lang("minerooms.manage.view.inv", {_player})
    set {_ender} to ender chest named lang("minerooms.manage.view.ender", {_player})
    set {_alert} to stick named lang("minerooms.manage.view.alert", {_player})
    set {_freeze} to blue ice named lang("minerooms.manage.view.freeze", {_player})
    set {_clear} to lava bucket named lang("minerooms.manage.view.clear", {_player})
    set {_kill} to netherite sword named lang("minerooms.manage.view.kill", {_player})
    set slot 19 of {_gui} to {_tp}
    set slot 20 of {_gui} to {_inv}
    set slot 21 of {_gui} to {_ender}
    set slot 22 of {_gui} to {_alert}
    set slot 23 of {_gui} to {_freeze}
    set slot 24 of {_gui} to {_clear}
    set slot 25 of {_gui} to {_kill}
    userData({_player}, "data.inv", "set", "manager.minerooms.manage.main")
on right click:
    set {_b} to event-block
    if "%type of {_b}%" contain "chest":
        if userDataBoolean(player, "player.vanish") is true:
            cancel event
            set {_s} to 3
            set {_x} to 27
            if "%type of {_b}%" is "chest":
                set {_s} to 6
                set {_x} to 54
            set {_gui} to genericGui(lang("minerooms.vanish.chestVisualizer.gui.title", player), {_s})
            open {_gui} for player
            userData(player, "data.inv", "set", "manager.minerooms.vanish.chestVisualizer.main")
            set {_slot} to 0
            loop {_x} times:
                set {_i} to slot {_slot} of {_b}
                set slot {_slot} of {_gui} to {_i}
                add 1 to {_slot}
function mineroomsFreeze(target: player, player: player):
    if userData({_target}, "player.freeze") is "true":
        add {_target}'s name to {_args::*}
        send formatted superLang("minerooms.freeze.youUnFreeze", {_player}, {_args::*}) to {_player}
        send formatted lang("minerooms.freeze.playerUnFreeze", {_target}) to {_target}
        userData({_target}, "player.freeze", "set", "false")
    else:
        add {_target}'s name to {_args::*}
        send formatted superLang("minerooms.freeze.youFreeze", {_player}, {_args::*}) to {_player}
        send formatted lang("minerooms.freeze.playerFreeze", {_target}) to {_target}
        userData({_target}, "player.freeze", "set", "true")
function mineroomsInvSee(player: player, target: player, cmd: boolean=false):
    open {_target}'s inventory to {_player}
    if {_cmd} is false:
        userData({_player}, "data.inv", "set", "manager.minerooms.manage.invsee.main")
function mineroomsEnderSee(player: player, target: player, cmd: boolean=false):
    open {_target}'s ender chest to {_player}
    if {_cmd} is false:
        userData({_player}, "data.inv", "set", "manager.minerooms.manage.endersee.main")
function mineroomsGetLanguage(player: player, split: boolean= true) :: text:
    set {_x} to language of {_player}
    if {_split} is true:
        set {_data::*} to {_x} split by "_"
        set {_x} to {_data::1}
    return {_x}
function mineroomsVanish(player: player):
    if userData({_player}, "player.vanish") is "true":
        loop all players:
            add {_player}'s name to {_args::*}
            if {_player} is not loop-player:
                if loop-player have permission "*":
                    send formatted superLang("minerooms.vanish.nowVisible", loop-player, {_args::*}) to loop-player
                else:
                    add loop-player to {_g::*}
            send formatted superLang("minerooms.vanish.join", loop-player, {_args::*}, "language", mineroomsGetLanguage(loop-player)) to loop-player
        reveal {_player} from all players
        userData({_player}, "player.vanish", "set", "false")
    else:
        loop all players:
            add {_player}'s name to {_args::*}
            if {_player} is not loop-player:
                if loop-player have permission "*":
                    send formatted superLang("minerooms.vanish.nowVanished", loop-player, {_args::*}) to loop-player
                else:
                    add loop-player to {_g::*}
            set {_x} to mineroomsGetLanguage(loop-player)
            send formatted superLang("minerooms.vanish.quit", loop-player, {_args::*}, "language", {_x}) to loop-player
        hide {_player} from {_g::*}
        userData({_player}, "player.vanish", "set", "true")
on join:
    ##send "§6[§aAntiExploitCore§6]§r %player's name% view distance (%client view distance of player%)" to console
    if userData(player, "player.vanish") is "true":
        set join message to ""
        loop all players:
            add player's name to {_args::*}
            if {_player} is not loop-player:
                if loop-player have permission "*":
                    send formatted superLang("minerooms.vanish.stillVanished", loop-player, {_args::*}) to loop-player
                    clear {_args::*}
                else:
                    add loop-player to {_g::*}
            reveal the loop-player from all players
            hide the loop-player from {_g::*}
    else:
        set join message to ""
        add player's name to {_args::*}
        loop all players:
            send formatted superLang("minerooms.vanish.join", loop-player, {_args::*}, "language", mineroomsGetLanguage(loop-player)) to loop-player
        send superLang("minerooms.vanish.join", player, {_args::*}, "language", "en") to console
on quit:
    if userData(player, "player.vanish") is "true":
        set quit message to ""
    else:
        set quit message to ""
        add player's name to {_args::*}
        loop all players:
            send formatted superLang("minerooms.vanish.quit", loop-player, {_args::*}, "language", mineroomsGetLanguage(loop-player)) to loop-player
        send superLang("minerooms.vanish.quit", player, {_args::*}, "language", "en") to console
    add player's name to {_args::*}
    add "%player's location%" to {_args::*}
    send superLang("minerooms.quit.coordinate", player, {_args::*}, "language", "en") to console
on pickup:
    if userData(player, "player.vanish") is "true":
        cancel event
on any move:
    if userData(player, "player.freeze") is "true":
        cancel event
on damage:
    if userData(victim, "player.vanish") is "true":
        cancel event
on join:
    if mineroomsGetRank(player) is "<none>":
        mineroomsSetRank(player, "wanderer", true)
    else if mineroomsGetAllRanks() doesn't contain userData(player, "player.rank"):
        mineroomsSetRank(player, "wanderer", true)
    if userData(player, "data.language") is "<none>":
        userData(player, "data.language", "set", languageConfig("data.defaultLanguage"))
    if userData(player, "player.chat") is "<none>":
        userData(player, "player.chat", "set", "default")
function mineroomsGetRestocks() :: objects:
    loop yaml node keys "restock" from "bck.manager.minerooms.data":
        add loop-node to {_dataList::*}
    loop {_dataList::*}:
        set {_x::*} to loop-value split by "."
        add {_x::2} to {_args::*}
    return {_args::*}
function mineroomsGetLevels(o: boolean=false) :: objects:
    loop yaml node keys "levels" from "bck.manager.minerooms.data":
        add loop-node to {_dataList::*}
    loop {_dataList::*}:
        set {_x::*} to loop-value split by "."
        set {_v} to {_x::2}
        if "%{_v}%" contain "-":
            replace all "-" with "." in {_v}
        if {_o} is true:
            add "Niveau_%{_v}%" to {_args::*}
        else:
            add {_v} to {_args::*}
    return {_args::*}
on inventory click:
    if userData(player, "data.inv") is "false":
        stop
    if userData(player, "data.inv") is "manager.minerooms.manage.main":
        cancel event
        set {_gui} to player's current inventory
        set {_i} to event-slot
        set {_t} to type of {_i}
        set {_n} to display name of {_i}
        set {_u} to {_n}
        set {_a} to item amount of event-slot
        if "%{_t}%" contain "barrier":
            if {_u} contain "Back":
                close player's inventory
        else if "%{_t}%" is "ender pearl":
            set {_x} to userData(player, "data.temp.manage") parsed as offlineplayer
            teleport player to {_x}
            play sound "entity.enderman.teleport" with volume 1 for player
            wait 10 ticks
            mineroomsManageGuiMain(player)
        else if "%{_t}%" is "chest":
            set {_x} to userData(player, "data.temp.manage") parsed as offlineplayer
            play sound "block.chest.open" with volume 1 for player
            mineroomsInvSee(player, {_x})
        else if "%{_t}%" is "ender chest":
            set {_x} to userData(player, "data.temp.manage") parsed as offlineplayer
            play sound "block.ender_chest.open" with volume 1 for player
            mineroomsEnderSee(player, {_x})
        else if "%{_t}%" is "stick":
            set {_x} to userData(player, "data.temp.manage") parsed as offlineplayer
            loop 10 times:
                send actionbar superLang("minerooms.topLuck.view.actionbar", {_x}, {_args::*}) to {_x}
                play sound "entity.firework_rocket.large_blast_far" with volume 1 with pitch 2 at {_x}
                wait 5 ticks
                play sound "entity.firework_rocket.large_blast_far" with volume 1 with pitch 0 at {_x}
                wait 1 seconds
        else if "%{_t}%" is "blue ice block":
            set {_x} to userData(player, "data.temp.manage") parsed as offlineplayer
            mineroomsFreeze({_x}, player)
            play sound "block.amethyst_block.resonate" with volume 1 with pitch 0 for player
        else if "%{_t}%" is "lava bucket":
            set {_x} to userData(player, "data.temp.manage") parsed as offlineplayer
            clear {_x}'s inventory
            play sound "block.lava.extinguish" with volume 1 with pitch 0.9 for player
        else if "%{_t}%" is "netherite sword":
            set {_x} to userData(player, "data.temp.manage") parsed as offlineplayer
            kill {_x}
            play sound "entity.player.death" with volume 1 with pitch 0 for player
    else if userData(player, "data.inv") is "manager.minerooms.vanish.chestVisualizer.main":
        cancel event
        set {_i} to event-slot
on inventory close:
    if userData(player, "data.inv") is "manager.minerooms.manage.invsee.main":
        play sound "block.chest.close" with volume 1 for player
        wait 1 ticks
        mineroomsManageGuiMain(player)
    else if userData(player, "data.inv") is "manager.minerooms.manage.endersee.main":
        play sound "block.ender_chest.close" with volume 1 for player
        wait 1 ticks
        mineroomsManageGuiMain(player)
command /bck_dev [<player>]:
    trigger:
        op arg-1
        stop
        #mineroomsTravel(player, arg-1)
        stop
        set {_se} to selector(player)
        loop getLanguages():
            set {_x} to loop-value
            load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
            set {_key} to "minerooms.firstJoin.pleaseSelectYourLanguage"
            set {_r} to yaml value {_key} from "bck.manager.language.%{_x}%"
            if "%{_r}%" is "<none>":
                set {_r} to {_key}
            add {_x} to {_args::*}
            set {_num} to 0
            loop {_args::*}:
                set {_v} to loop-value-2
                replace all "<arg%{_num}%>" with {_v} in {_r}
                add 1 to {_num}
            send formatted {_r} to player
            clear {_args::*}
on first join:
    set {_se} to selector(player)
    loop getLanguages():
        set {_x} to loop-value
        load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
        set {_key} to "minerooms.firstJoin.pleaseSelectYourLanguage"
        set {_r} to yaml value {_key} from "bck.manager.language.%{_x}%"
        if "%{_r}%" is "<none>":
            set {_r} to {_key}
        add {_x} to {_args::*}
        set {_num} to 0
        loop {_args::*}:
            set {_v} to loop-value-2
            replace all "<arg%{_num}%>" with {_v} in {_r}
            add 1 to {_num}
        send formatted {_r} to player
        clear {_args::*}
    make console execute command "/team join wanderer %player's name%"
    wait 5 seconds
    set player's helmet to golden helmet
    set player's chestplate to golden chestplate
    set player's leggings to golden leggings
    set player's boots to golden boots
    wait 1 seconds
    mineroomsTravel(player, 0, true)
on place:
    set {_b} to event-block
    set {_i} to event-item
    set {_cx} to x-coordinate of {_b}
    set {_cy} to y-coordinate of {_b}
    set {_cz} to z-coordinate of {_b}
    set {_cw} to {_b}'s world
    set {_x} to line 2 of lore of {_i}
    replace "§d" with "" in {_x}
    replace "§b" with "" in {_x}
    if {_x} contain "<lang:":
        set {_data::*} to {_x} split by ":"
        set {_k} to {_data::2}
        replace ">" with "" in {_k}
        set {_blocks::*} to yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd"
        add "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%|%{_k}%" to {_blocks::*}
        set yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd" to {_blocks::*}
        save yaml "bck.manager.minerooms.bdd"
        add {_k} to {_args::*}
        send actionbar formatted superLang("minerooms.command.lore.added", player, {_args::*}) to player
        play sound "entity.experience_orb.pickup" with volume 0.3 for player
    else if {_x} contain "<restock:":
        set {_data::*} to {_x} split by ":"
        set {_k} to {_data::2}
        replace ">" with "" in {_k}
        set {_supplys::*} to yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd"
        add "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%|%{_k}%" to {_supplys::*}
        set yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd" to {_supplys::*}
        save yaml "bck.manager.minerooms.bdd"
        add {_k} to {_args::*}
        send actionbar formatted superLang("minerooms.command.restock.added", player, {_args::*}) to player
        play sound "entity.experience_orb.pickup" with volume 0.3 for player
    else if {_x} contain "<coordinate:":
        set {_data::*} to {_x} split by ":"
        set {_k} to {_data::2}
        replace ">" with "" in {_k}
        set {_coo::*} to {_k} split by "_"
        set {_x} to {_coo::1}
        set {_y} to {_coo::2}
        set {_z} to {_coo::3}
        set {_loc} to location({_x}, {_y}, {_z})
        set {_coordinates::*} to yaml list "minerooms.coordinate.coordinates" from "bck.manager.minerooms.bdd"
        add "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%|%{_x}%|%{_y}%|%{_z}%" to {_coordinates::*}
        set yaml list "minerooms.coordinate.coordinates" from "bck.manager.minerooms.bdd" to {_coordinates::*}
        save yaml "bck.manager.minerooms.bdd"
        add "%{_x}%_%{_y}%_%{_z}%" to {_args::*}
        send actionbar formatted superLang("minerooms.command.coordinate.added", player, {_args::*}) to player
        play sound "entity.experience_orb.pickup" with volume 0.3 for player
    else if {_x} contain "<travel:":
        set {_data::*} to {_x} split by ":"
        set {_k} to {_data::2}
        replace ">" with "" in {_k}
        set {_travels::*} to yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd"
        add "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%|%{_k}%" to {_travels::*}
        set yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd" to {_travels::*}
        save yaml "bck.manager.minerooms.bdd"
        add {_k} to {_args::*}
        send actionbar formatted superLang("minerooms.command.travel.added", player, {_args::*}) to player
        play sound "entity.experience_orb.pickup" with volume 0.3 for player
on break:
    set {_b} to event-block
    set {_i} to event-item
    set {_cx} to x-coordinate of {_b}
    set {_cy} to y-coordinate of {_b}
    set {_cz} to z-coordinate of {_b}
    set {_cw} to {_b}'s world
    set {_blocks::*} to yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd"
    set {_supplys::*} to yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd"
    set {_travels::*} to yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd"
    set {_coordinates::*} to yaml list "minerooms.coordinate.coordinates" from "bck.manager.minerooms.bdd"
    if "%{_blocks::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
        loop {_blocks::*}:
            set {_x} to loop-value
            set {_xs::*} to {_x} split by "|"
            if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                add {_xs::5} to {_args::*}
                send actionbar formatted superLang("minerooms.command.lore.removed", player, {_args::*}) to player
                play sound "block.note_block.bit" with volume 0.3 with pitch 0 for player
            else:
                add {_x} to {_r::*}
        set yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd" to {_r::*}
        save yaml "bck.manager.minerooms.bdd"
    else if "%{_supplys::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
        loop {_supplys::*}:
            set {_x} to loop-value
            set {_xs::*} to {_x} split by "|"
            if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                add {_xs::5} to {_args::*}
                send actionbar formatted superLang("minerooms.command.restock.removed", player, {_args::*}) to player
                play sound "block.note_block.bit" with volume 0.3 with pitch 0 for player
            else:
                add {_x} to {_r::*}
        set yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd" to {_r::*}
        save yaml "bck.manager.minerooms.bdd"
    else if "%{_travels::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
        loop {_travels::*}:
            set {_x} to loop-value
            set {_xs::*} to {_x} split by "|"
            if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                add {_xs::5} to {_args::*}
                send actionbar formatted superLang("minerooms.command.travel.removed", player, {_args::*}) to player
                play sound "block.note_block.bit" with volume 0.3 with pitch 0 for player
            else:
                add {_x} to {_r::*}
        set yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd" to {_r::*}
        save yaml "bck.manager.minerooms.bdd"
    else if "%{_coordinates::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
        loop {_coordinates::*}:
            set {_x} to loop-value
            set {_xs::*} to {_x} split by "|"
            if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                add "%{_xs::5}%_%{_xs::6}%_%{_xs::7}%" to {_args::*}
                send actionbar formatted superLang("minerooms.command.coordinate.removed", player, {_args::*}) to player
                play sound "block.note_block.bit" with volume 0.3 with pitch 0 for player
            else:
                add {_x} to {_r::*}
        set yaml list "minerooms.coordinate.coordinates" from "bck.manager.minerooms.bdd" to {_r::*}
        save yaml "bck.manager.minerooms.bdd"
on break of item frame:
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if mineroomsData("levels.%{_name}%.breakItemFrame") is "false":
        if "%player's gamemode%" is not "creative":
            cancel event
on break of armor stand:
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if mineroomsData("levels.%{_name}%.breakArmorStand") is "false":
        if "%player's gamemode%" is not "creative":
            cancel event
on break of painting:
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if mineroomsData("levels.%{_name}%.breakPainting") is "false":
        if "%player's gamemode%" is not "creative":
            cancel event
on damage:
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if victim is item frame:
        if mineroomsData("levels.%{_name}%.breakItemFrame") is "false":
            if "%attacker's gamemode%" is not "creative":
                cancel event
    if victim is armor stand:
        if mineroomsData("levels.%{_name}%.breakArmorStand") is "false":
            if "%attacker's gamemode%" is not "creative":
                cancel event
    if victim is painting:
        if mineroomsData("levels.%{_name}%.breakPainting") is "false":
            if "%attacker's gamemode%" is not "creative":
                cancel event
on right click on item frame:
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if mineroomsData("levels.%{_name}%.breakItemFrame") is "false":
        if "%player's tool%" is not "air":
            if "%player's gamemode%" is not "creative":
                cancel event
                stop
on right click on armor stand:
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if mineroomsData("levels.%{_name}%.breakArmorStand") is "false":
        if "%player's gamemode%" is not "creative":
            cancel event
            stop
on drop:
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if mineroomsData("levels.%{_name}%.dropItem") is "false":
        if "%player's gamemode%" is not "creative":
            cancel event
            stop
on spawn:
    set {_e} to event-entity
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    set {_a::*} to yaml list "levels.%{_name}%.mobSpawn.alloy" from "bck.manager.minerooms.data"
    set {_t} to "%type of {_e}%"
    if {_t} contain "dropped":
        stop
    if {_t} contain "painting":
        stop
    if {_t} contain "item frame":
        stop
    if {_t} contain "armor stand":
        stop
    if {_t} contain "falling":
        stop
    if {_t} contain "block display":
        stop
    replace all "_" with " " in {_t}
    if {_a::*} doesn't contain "%{_t}%":
        cancel event
        #broadcast "%type of {_e}% => §ccancelled"
on right click:
    set {_e} to event-entity
    set {_b} to event-block
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if {_b} is set:
        set {_cx} to x-coordinate of {_b}
        set {_cy} to y-coordinate of {_b}
        set {_cz} to z-coordinate of {_b}
        if "%type of {_b}%" is "filled composter":
            cancel event
            stop
        if "%type of {_b}%" is "filled composter":
            if "%player's tool%" is not "air":
                if "%player's gamemode%" is not "creative":
                    cancel event
                    stop
        if "%type of {_b}%" contain "sign":
            if mineroomsData("levels.%{_name}%.editSign") is "false":
                if "%player's gamemode%" is not "creative":
                    cancel event
                    stop
        if "%type of {_b}%" contain "pot":
            if mineroomsData("levels.%{_name}%.grabFlowerPot") is "false":
                if "%player's gamemode%" is not "creative":
                    cancel event
                    stop
        if "%type of {_b}%" contain "door":
            if "%type of {_b}%" contain "trapdoor":
                if mineroomsData("levels.%{_name}%.openTrapDoor") is "false":
                    if "%player's gamemode%" is not "creative":
                        cancel event
                        stop
            else if mineroomsData("levels.%{_name}%.openDoor") is "false":
                if "%player's gamemode%" is not "creative":
                    cancel event
                    stop
        set {_cw} to {_b}'s world
        set {_blocks::*} to yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.bdd"
        set {_supplys::*} to yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.bdd"
        if "%{_blocks::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
            loop {_blocks::*}:
                set {_x} to loop-value
                set {_xs::*} to {_x} split by "|"
                if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                    if player cannot hold 1 written book:
                        cancel event
                        stop
                    cancel event
                    play sound "entity.elder_guardian.ambient" with volume 0.5 with pitch 2 for player
                    set {_x} to userData(player, "data.language")
                    if "%{_x}%" is "<none>":
                        set {_x} to languageConfig("data.defaultLanguage")
                        userData(player, "data.language", "set", {_x})
                    load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
                    set {_pages::*} to yaml list "%{_xs::5}%.pages" from "bck.manager.language.%{_x}%"
                    set {_name} to lang("%{_xs::5}%.name", player)
                    set {_a} to lang("%{_xs::5}%.author", player)
                    set {_w} to ""
                    loop {_pages::*}:
                        set {_v} to loop-value-2
                        if loop-index-2 is "1":
                            set {_w} to "'{""text"":""%{_v}%""}'"
                        else:
                            set {_w} to "%{_w}%,'{""text"":""%{_v}%""}'"
                    set {_cmd} to "/give %player's name% written_book{pages:[%{_w}%],title:""%{_name}%"",author:""%{_a}%""}"
                    make console execute command {_cmd}
                    set {_ss} to 0
                    loop 36 times:
                        set {_i} to slot {_ss} of player's inventory
                        if "%{_i}%" is "written book":
                            open book {_i} to player
                            set slot {_ss} of player's inventory to air
                            exit loop
                        add 1 to {_ss}
        else if "%{_supplys::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
            if player cannot hold 1 barrier:
                cancel event
                stop
            play sound "block.note_block.bit" with volume 0.7 with pitch 0.8 for player
            send title lang("minerooms.command.restock.collected", player) to player
            loop {_supplys::*}:
                set {_x} to loop-value
                set {_xs::*} to {_x} split by "|"
                if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                    loop yaml node keys "restock.%{_xs::5}%" from "bck.manager.minerooms.data":
                        add loop-node to {_dataList::*}
                    loop {_dataList::*}:
                        set {_i} to loop-value-2
                        set {_ii} to loop-value-2
                        set {_i::*} to {_i} split by "."
                        set {_i} to {_i::3}
                        replace all "_" with " " in {_i}
                        set {_i} to {_i} parsed as item
                        
                        set {_restockMin} to yaml value "%{_ii}%.min" from "bck.manager.minerooms.data" 
                        set {_restockMax} to yaml value "%{_ii}%.max" from "bck.manager.minerooms.data" 
                        set {_restockChance} to yaml value "%{_ii}%.chance" from "bck.manager.minerooms.data"
                        set {_restockMin} to "%{_restockMin}%" parsed as integer
                        set {_restockMax} to "%{_restockMax}%" parsed as integer
                        set {_restockChance} to "%{_restockChance}%" parsed as integer
                        set {_restockCustomName} to mineroomsServerConfig("%{_ii}%.custom.name")
                        set {_restockCustomLores::*} to yaml list "%{_ii}%.custom.lores" from "bck.manager.minerooms.data"
                        set {_item} to {_i}
                        if {_restockCustomName} is set:
                            set {_item} to {_i} named {_restockCustomName}
                        if {_restockCustomLores::*} is set:
                            set {_b} to 1
                            loop {_restockCustomLores::*}:
                                set {_v} to loop-value-3
                                if {_v} contain "<lang:":
                                    set {_vv::*} to {_v} split by ":"
                                    set {_k} to {_vv::2}
                                    replace ">" with "" in {_k}
                                    set {_v} to lang({_k}, player) 
                                set line {_b} of lore of {_item} to {_v}
                                add 1 to {_b}
                        set {_restockCount} to rng({_restockMin}, {_restockMax})
                        if player cannot hold {_restockCount} of {_item}:
                            cancel event
                            stop
                        cancel event
                        chance of {_restockChance}%:
                            give {_restockCount} of {_item} to player
                    
    else if {_e} is set:

every 10 second:
    loop all players:
        set {_x} to loop-player
        set {bck.minerooms.temp.%{_x}'s name%.travel} to false
        set {bck.minerooms.temp.%{_x}'s name%.coordinate} to false
on respawn:
    wait 1 tick
    if "%type of player%" is "player":
        play sound "entity.enderman.teleport" with volume 1 with pitch 0.8 for player
        mineroomsTravel(player, 0, true)
        play sound "entity.enderman.teleport" with volume 1 with pitch 0.8 for player
every 10 ticks:
    loop all players:
        set {_b} to block below loop-player
        if {_b} is set:
            if {bck.minerooms.temp.%loop-player's name%.travel} is true:
                stop
            if {bck.minerooms.temp.%loop-player's name%.coordinate} is true:
                stop
            set {_cx} to x-coordinate of {_b}
            set {_cy} to y-coordinate of {_b}
            set {_cz} to z-coordinate of {_b}
            set {_cw} to {_b}'s world
            if {bck.minerooms.temp.%loop-player's name%.travel} is false: 
                set {_travels::*} to yaml list "minerooms.travel.travels" from "bck.manager.minerooms.bdd"
                if "%{_travels::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                    set {bck.minerooms.temp.%loop-player's name%.travel} to true
                    loop {_travels::*}:
                        set {_x} to loop-value-2
                        set {_xs::*} to {_x} split by "|"
                        if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                            set {_f} to {_xs::5}
                            if "%{_f}%" contain "-":
                                set {_f} to "%{_f}%"
                                replace all "-" with "." in {_f}
                            replace "Niveau_" with "" in {_f}
                            set {_f} to "%{_f}%" parsed as number
                            play sound "entity.enderman.teleport" with volume 1 with pitch 0.8 for loop-player
                            mineroomsTravel(loop-player, {_f}, true)
                            play sound "entity.enderman.teleport" with volume 1 with pitch 0.8 for loop-player
            if {bck.minerooms.temp.%loop-player's name%.coordinate} is false: 
                set {_coordinates::*} to yaml list "minerooms.coordinate.coordinates" from "bck.manager.minerooms.bdd"
                if "%{_coordinates::*}%" contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                    set {bck.minerooms.temp.%loop-player's name%.coordinate} to true
                    loop {_coordinates::*}:
                        set {_x} to loop-value-2
                        set {_xs::*} to {_x} split by "|"
                        if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                            set {_x} to {_xs::5}
                            set {_x} to "%{_x}%" parsed as number
                            set {_y} to {_xs::6}
                            set {_y} to "%{_y}%" parsed as number
                            set {_z} to {_xs::7}
                            set {_z} to "%{_z}%" parsed as number
                            set {_ww} to world("%{_cw}%")
                            set {_ff} to location({_x},{_y},{_z}, {_ww})
                            teleport loop-player to {_ff}
                            #broadcast "%{_ff}% / %{_ww}% / %{_cw}%"
                            play sound "entity.enderman.teleport" with volume 1 with pitch 0.8 for loop-player


function mineroomsTravel(player: player, level: number=-1, message: boolean=true):
    set {_levelBis} to "%{_level}%"
    replace all "." with "-" in {_levelBis}
    set {_levelName} to mineroomsData("levels.%{_levelBis}%.name")
    set {_levelDanger} to mineroomsData("levels.%{_levelBis}%.survival_difficulty")
    set {_levelSecure} to mineroomsData("levels.%{_levelBis}%.secure")
    set {_levelStable} to mineroomsData("levels.%{_levelBis}%.stable")
    set {_levelEntity} to mineroomsData("levels.%{_levelBis}%.entity")
    set {_levelPvp} to mineroomsData("levels.%{_levelBis}%.pvp")
    set {_levelEffectType} to mineroomsData("levels.%{_levelBis}%.effect.type")
    set {_levelEffectEffects::*} to yaml list "levels.%{_levelBis}%.effect.effects" from "bck.manager.minerooms.data"
    set {_levelNameBis} to configLang({_levelName}, {_player}, "language", true)
    make console execute command "/mvtp %{_player}'s name% %{_levelNameBis}%"
    wait 1 tick
    clear all the potion effects of {_player}
    if "%{_levelEffectType}%" is "1":
        loop {_levelEffectEffects::*}:
            set {_v} to loop-value
            set {_data::*} to "%{_v}%" split by "|"
            set {_e} to {_data::1}
            set {_t} to {_data::2}
            set {_d} to {_data::3}
            set {_dd} to {_d}
            set {_p} to {_data::4}
            set {_e} to "%{_e}%"
            replace all "_" with " " in {_e}
            set {_e} to "%{_e}%" parsed as potiontype
            set {_t} to "%{_t}%" parsed as integer
            set {_d} to "%{_d}%" parsed as integer
            set {_p} to "%{_p}%" parsed as boolean
            if {_t} is not set:
                set {_t} to 1
            if {_d} is not set:
                set {_d} to 20
            set {_di} to {_d} * 20
            if {_p} is not set:
                set {_p} to false
            if {_p} is false:
                if {_dd} is "inf":
                    apply infinite potion of {_e} of tier {_t} without particles to {_player}
                else:
                    set {_f} to potion effect of {_e} of tier {_t} without particles for {_di}
                    add {_f} to potion effects of {_player}
            else:
                set {_f} to potion effect of {_e} of tier {_t} for {_di}
                add {_f} to potion effects of {_player}
    if {_message} is true:
        set {_ti} to mineroomsGetLevel({_player}, {_level})
        replace all "-" with "." in {_ti}
        send title {_ti} to {_player}
        send subtitle lang("minerooms.functions.travel.%{_levelBis}%.name", {_player}) to {_player}
        set {_pvp} to "§2☻"
        if {_levelPvp} is "true":
            set {_pvp} to "§4☠"
            addPermission({_player}, "player.attack", true)
        else:
            removePermission({_player}, "player.attack", true)
        add "%{_levelDanger}%" to {_args::*}
        add {_pvp} to {_args::*}
        send actionbar superLang("minerooms.functions.travel.actionBar", {_player}, {_args::*}) to {_player}
        wait 1.5 seconds
        send title {_ti} to {_player}
        send subtitle lang("minerooms.functions.travel.secure.%{_levelSecure}%", {_player}) to {_player}
        send actionbar superLang("minerooms.functions.travel.actionBar", {_player}, {_args::*}) to {_player}
        wait 1.5 seconds
        send title {_ti} to {_player}
        send subtitle lang("minerooms.functions.travel.stable.%{_levelStable}%", {_player}) to {_player}
        send actionbar superLang("minerooms.functions.travel.actionBar", {_player}, {_args::*}) to {_player}
        wait 1.5 seconds
        send title {_ti} to {_player}
        send subtitle lang("minerooms.functions.travel.entity.%{_levelEntity}%", {_player}) to {_player}
        send actionbar superLang("minerooms.functions.travel.actionBar", {_player}, {_args::*}) to {_player}
on chat:
    cancel event
    set {_xc} to false
    loop all players:
        set {_x} to loop-player
        if userData(player, "player.chat") is "default":
            if {_x}'s world is player's world:
                set {_mb} to mineroomsData("chat.message")
                set {_rank} to userData(player, "player.rank")
                set {_rankName} to lang("minerooms.ranks.%{_rank}%.name", loop-player)
                if "%{_rankName}%" is "<none>":
                    set {_rankName} to ""
                
                
                if {_rankName} contain "§l":
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::2}%"
                    set {_rankColor} to "%{_rankColor}%§l"
                else:
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::1}%"
                set {_mb} to "%{_mb}%"
                set {_c} to 0
                add {_rankColor} to {_args::*}
                add {_rankName} to {_args::*}
                add player's name to {_args::*}
                add message to {_args::*}
                loop {_args::*}:
                    set {_v} to loop-value-2
                    replace all "<arg%{_c}%>" with "%{_v}%" in {_mb}
                    add 1 to {_c}
                send formatted {_mb} to loop-player
                send formatted "§6[§b%player's world%§6]§r %{_rankName}% %{_mb}%" to console
                clear {_args::*}
        else if userData(player, "player.chat") is "staff":
            if hasPermission(player, "op"):
                set {_mb} to mineroomsData("chat.staffMessage")
                set {_rank} to userData(player, "player.rank")
                set {_rankName} to lang("minerooms.ranks.%{_rank}%.name", loop-player)
                if "%{_rankName}%" is "<none>":
                    set {_rankName} to ""
                if {_rankName} contain "§l":
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::2}%"
                    set {_rankColor} to "%{_rankColor}%§l"
                else:
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::1}%"
                set {_mb} to "%{_mb}%"
                set {_c} to 0
                add "🔒" to {_args::*}
                add {_rankColor} to {_args::*}
                add {_rankName} to {_args::*}
                add player's name to {_args::*}
                add message to {_args::*}
                loop {_args::*}:
                    set {_v} to loop-value-2
                    replace all "<arg%{_c}%>" with "%{_v}%" in {_mb}
                    add 1 to {_c}
                send formatted {_mb} to loop-player
                send formatted "§6[§b%player's world%§6]§r %{_rankName}% %{_mb}%" to console
                clear {_args::*}
        else if userData(player, "player.chat") is "all":
            set {_mb} to mineroomsData("chat.message")
            set {_rank} to userData(player, "player.rank")
            set {_rankName} to lang("minerooms.ranks.%{_rank}%.name", loop-player)
            if "%{_rankName}%" is "<none>":
                set {_rankName} to ""
            if {_rankName} contain "§l":
                set {_cc::*} to {_rankName} split by "§"
                set {_rankColor} to "§%{_cc::2}%"
                set {_rankColor} to "%{_rankColor}%§l"
            else:
                set {_cc::*} to {_rankName} split by "§"
                set {_rankColor} to "§%{_cc::1}%"
            set {_mb} to "%{_mb}%"
            set {_c} to 0
            add {_rankColor} to {_args::*}
            add {_rankName} to {_args::*}
            add player's name to {_args::*}
            add message to {_args::*}
            loop {_args::*}:
                set {_v} to loop-value-2
                replace all "<arg%{_c}%>" with "%{_v}%" in {_mb}
                add 1 to {_c}
            send formatted {_mb} to loop-player
            send formatted "§6[§b%player's world%§6]§r %{_rankName}% %{_mb}%" to console
            clear {_args::*}
        else if userData(player, "player.chat") is "meg":
            if mineroomsGetRank({_x}) is "meg_member":
                set {_mb} to mineroomsData("chat.megMessage")
                set {_rank} to userData(player, "player.rank")
                set {_rankName} to lang("minerooms.ranks.%{_rank}%.name", player)
                if "%{_rankName}%" is "<none>":
                    set {_rankName} to ""
                if {_rankName} contain "§l":
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::2}%"
                    set {_rankColor} to "%{_rankColor}%§l"
                else:
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::1}%"
                set {_mb} to "%{_mb}%"
                set {_c} to 0
                add "M.E.G" to {_args::*}
                add {_rankColor} to {_args::*}
                add {_rankName} to {_args::*}
                add player's name to {_args::*}
                add message to {_args::*}
                loop {_args::*}:
                    set {_v} to loop-value-2
                    replace all "<arg%{_c}%>" with "%{_v}%" in {_mb}
                    add 1 to {_c}
                send formatted {_mb} to loop-player
                send formatted "§6[§b%player's world%§6]§r %{_rankName}% %{_mb}%" to console
                clear {_args::*}
        else if "%mineroomsGetLevels(true)%" contain userData(player, "player.chat"):
            if {_xc} is false:
                set {_mb} to mineroomsData("chat.levelMessage")
                set {_rank} to userData(player, "player.rank")
                set {_rankName} to lang("minerooms.ranks.%{_rank}%.name", player)
                if "%{_rankName}%" is "<none>":
                    set {_rankName} to ""
                if {_rankName} contain "§l":
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::2}%"
                    set {_rankColor} to "%{_rankColor}%§l"
                else:
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::1}%"
                set {_mb} to "%{_mb}%"
                set {_c} to 0
                #set {_levelName} to configLang(, {_player})
                set {_levelName} to userData(player, "player.chat")
                replace "Niveau_" with "" in {_levelName}
                add lang("minerooms.command.noClip.levels.%{_levelName}%", player) to {_args::*}
                add {_rankColor} to {_args::*}
                add {_rankName} to {_args::*}
                add player's name to {_args::*}
                add message to {_args::*}
                loop {_args::*}:
                    set {_v} to loop-value-2
                    replace all "<arg%{_c}%>" with "%{_v}%" in {_mb}
                    add 1 to {_c}
                send formatted {_mb} to player
                set {_xc} to true
                clear {_args::*}
            if loop-player's world is userData(player, "player.chat"):
                set {_mb} to mineroomsData("chat.message")
                set {_rank} to userData(player, "player.rank")
                set {_rankName} to lang("minerooms.ranks.%{_rank}%.name", loop-player)
                if "%{_rankName}%" is "<none>":
                    set {_rankName} to ""
                if {_rankName} contain "§l":
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::2}%"
                    set {_rankColor} to "%{_rankColor}%§l"
                else:
                    set {_cc::*} to {_rankName} split by "§"
                    set {_rankColor} to "§%{_cc::1}%"
                set {_mb} to "%{_mb}%"
                set {_c} to 0
                add {_rankColor} to {_args::*}
                add {_rankName} to {_args::*}
                add player's name to {_args::*}
                add message to {_args::*}
                loop {_args::*}:
                    set {_v} to loop-value-2
                    replace all "<arg%{_c}%>" with "%{_v}%" in {_mb}
                    add 1 to {_c}
                send formatted {_mb} to loop-player
                send formatted "§6[§b%player's world%§6]§r %{_rankName}% %{_mb}%" to console
                clear {_args::*}
function mineroomsNoClip(player: player):
    set {_gui} to genericGui(lang("minerooms.command.noClip.gui.title", {_player}), 5, true)
    set slot 22 of {_gui} to redstone block named "§4Wait.."
    userData({_player}, "data.inv", "set", "manager.minerooms.noClip.main")
    open {_gui} to {_player}
    mineroomsNoClipGuiUpdater({_player})
function mineroomsNoClipGuiUpdater(player: player):
    set {_gui} to {_player}'s current inventory
    set slot 22 of {_gui} to air
    set {_sc} to 10
    set {_gc} to 0
    loop 24 times:
        if {_gc} is 10 or 19 or 28:
            add 7 to {_gc}
        else if {_gc} is 40:
            add 1 to {_gc}
        set slot {_gc} of {_gui} to yellow stained glass pane named "§l"
        add 1 to {_gc}
    loop yaml node keys "levels" from "bck.manager.minerooms.data":
        add loop-node to {_levelsList::*}
    loop {_levelsList::*}:
        if {_sc} = 17 or 26:
            add 2 to {_sc}
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_levelName} to mineroomsData("%loop-value%.name")
        set {_levelDanger} to mineroomsData("%loop-value%.survival_difficulty")
        set {_levelSecure} to mineroomsData("%loop-value%.secure")
        set {_levelStable} to mineroomsData("%loop-value%.stable")
        set {_levelEntity} to mineroomsData("%loop-value%.entity")
        set {_levelPvp} to mineroomsData("%loop-value%.pvp")
        set {_levelName} to configLang({_levelName}, {_player})
        if {_levelName} is not lang("minerooms.command.noClip.levels.-1", {_player}):
            if {_levelName} is "<none>":
                set {_levelName} to "??"
            replace all "_" with " " in {_levelName}
            set {_i} to paper named {_levelName}
            add {_levelDanger} to {_args::*}
            set line 2 of lore of {_i} to superLang("minerooms.command.noClip.gui.survival_difficulty", {_player}, {_args::*})
            clear {_args::*}
            if {_levelSecure} is "true":
                set {_levelSecure} to "§a✔"
            else:
                set {_levelSecure} to "§c✖"
            add {_levelSecure} to {_args::*}
            set line 3 of lore of {_i} to superLang("minerooms.command.noClip.gui.secure", {_player}, {_args::*})
            clear {_args::*}
            if "%{_levelStable}%" is "true":
                set {_levelStable} to "§a✔"
            else:
                set {_levelStable} to "§c✖"
            add {_levelStable} to {_args::*}
            set line 4 of lore of {_i} to superLang("minerooms.command.noClip.gui.stable", {_player}, {_args::*})
            clear {_args::*}
            add lang("minerooms.functions.travel.entity.%{_levelEntity}%", {_player}) to {_args::*}
            set line 5 of lore of {_i} to superLang("minerooms.command.noClip.gui.entity", {_player}, {_args::*})
            clear {_args::*}
            set {_pvp} to "§2☻"
            if {_levelPvp} is "true":
                set {_pvp} to "§4☠"
            add {_pvp} to {_args::*}
            set line 6 of lore of {_i} to superLang("minerooms.command.noClip.gui.pvp", {_player}, {_args::*})
            clear {_args::*}
            add {_levelName} to {_args::*}
            set line 8 of lore of {_i} to superLang("minerooms.command.noClip.gui.clickToTeleport", {_player}, {_args::*})
            set slot {_sc} of {_gui} to {_i}
            clear {_args::*}
            add 1 to {_sc}
    userData({_player}, "data.inv", "set", "manager.minerooms.noClip.main")
function mineroomsRankListGuiUpdater(player: player):
    set {_gui} to {_player}'s current inventory
    set slot 22 of {_gui} to air
    set {_sc} to 10
    set {_gc} to 0
    loop 24 times:
        if {_gc} is 10 or 19 or 28:
            add 7 to {_gc}
        else if {_gc} is 40:
            add 1 to {_gc}
        set slot {_gc} of {_gui} to yellow stained glass pane named "§l"
        add 1 to {_gc}
    loop yaml node keys "ranks" from "bck.manager.minerooms.data":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_rankName} to mineroomsData("%loop-value%.name")
        if {_rankName} is not set:
            set {_rankName} to "minerooms.ranks.%{_r}%.name"
        set {_perms::*} to yaml list "%loop-value%.perms" from "bck.manager.minerooms.data"
        if "%{_perms::*}%" is not "<none>":
            set {_rank.perms::*} to yaml list "%loop-value%.perms" from "bck.manager.minerooms.data"
        set {_i} to paper named configLang({_rankName}, {_player})
        set line 1 of lore of {_i} to lang("minerooms.command.ranks.list.gui.permissions", {_player})
        set {_rf} to 2
        loop {_rank.perms::*}:
            set {_x} to loop-value-2
            add "%{_x}%" to {_args::*}
            set line {_rf} of lore of {_i} to superLang("minerooms.command.ranks.list.gui.genericPermission", {_player}, {_args::*})
            add 1 to {_rf}
            clear {_args::*}
        set slot {_sc} of {_gui} to {_i}
        add 1 to {_sc}
        wait 1 tick
    userData({_player}, "data.inv", "set", "manager.minerooms.ranks.list.main")
on inventory click:
    if userData(player, "data.inv") is "false":
        stop
    if userData(player, "data.inv") is "manager.minerooms.noClip.main":
        cancel event
        set {_gui} to player's current inventory
        set {_i} to event-slot
        set {_t} to type of {_i}
        set {_n} to display name of {_i}
        set {_u} to {_n}
        set {_a} to item amount of event-slot
        if "%{_t}%" contain "barrier":
            if {_u} contain "Back":
                close player's inventory
        else:
            if "%{_t}%" contain "paper":
                loop yaml node keys "levels" from "bck.manager.minerooms.data":
                    add loop-node to {_levelsList::*}
                loop {_levelsList::*}:
                    if {_sc} = 17 or 27:
                        add 2 to {_sc}
                    set {_r} to loop-value
                    set {_r::*} to {_r} split by "."
                    set {_r} to {_r::2}
                    set {_levelName} to mineroomsData("%loop-value%.name")
                    set {_levelNameBis} to configLang({_levelName}, player, "language", true)
                    set {_levelName} to configLang({_levelName}, player)
                    replace all "_" with " " in {_levelName}
                    if {_u} is {_levelName}:
                        close player's inventory
                        replace all "-" with "." in {_r}
                        set {_xx} to "%{_r}%" parsed as number
                        #broadcast "%{_levelName}% = %{_r}%"
                        mineroomsTravel(player, {_xx}, true)
                        #make console execute command "/mvtp %player's name% %{_levelNameBis}%"
    else if userData(player, "data.inv") is "manager.minerooms.ranks.list.main":
        cancel event
        set {_gui} to player's current inventory
        set {_i} to event-slot
        set {_t} to type of {_i}
        set {_n} to display name of {_i}
        set {_u} to {_n}
        set {_a} to item amount of event-slot
        if "%{_t}%" contain "barrier":
            if {_u} contain "Back":
                close player's inventory
function mineroomsGetLevel(player: player, num: number=-1, def: boolean=false) :: text:
    if "%{_num}%" contain ".":
        set {_num} to "%{_num}%"
        replace all "." with "-" in {_num}
    set {_r} to configLang(mineroomsData("levels.%{_num}%.name"), {_player})
    if {_def} is false:
        replace all "_" with " " in {_r}
    return {_r}
#                                      mineroomsGetAllRanks functions                                                                          #
function mineroomsGetAllRanks() :: objects:
    loop yaml node keys "ranks" from "bck.manager.minerooms.data":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        add "%{_r}%" to {_return::*}
    return {_return::*}
#                                      mineroomsSetRank functions                                                                          #
function mineroomsSetRank(player: player, rank: text="wanderer", autoPerm: boolean=false):
    userData({_player}, "player.rank", "set", {_rank})
    set {_s} to selector({_player})
    superLog("§6[§4BCK§6/§eMineRooms§6]§r Rank of §7%{_s}% §rhas been set to §7%{_rank}%", "3")
    superLog("§6[§4BCK§6/§eMineRooms§6]§r Rank of §7%{_player}'s name% §rhas been set to §7%{_rank}%", "6", true)
    if {_autoPerm} is true:
        loop {server.permission.%{_player}'s name%.list::*}:
            if loop-value is not "server.owner":
                removePermission({_player}, loop-value, true)
        loop mineroomsGetRankPerms({_rank}):
            set {_x} to loop-value
            if "%{_x}%" contain "permissions":
                set {_data::*} to "%{_x}%" split by "."
                set {_w} to {_data::2}
                loop mineroomsGetRankPerms({_w}):
                    set {_xx} to loop-value-2
                    if {_xx} doesn't contain "permission":
                        addPermission({_player}, {_xx}, true)
            else:
                addPermission({_player}, {_x}, true)
#                                      mineroomsGetRank functions                                                                          #
function mineroomsGetRank(player: player) :: text:
    set {_r} to userData({_player}, "player.rank")
    return "%{_r}%"
#                                      mineroomsGetRankPerms functions                                                                          #
function mineroomsGetRankPerms(rank: text="?", player: text="?") :: objects:
    if {_rank} is "?":
        if {_player} is not "?":
            set {_player} to {_player} parsed as player
            set {_rank} to userData({_player}, "player.rank")
        set {_perms::*} to yaml list "ranks.%{_rank}%.perms" from "bck.manager.minerooms.data"
    else:
        set {_perms::*} to yaml list "ranks.%{_rank}%.perms" from "bck.manager.minerooms.data"
    return {_perms::*}
    
    set {_s} to selector({_player})
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_s}% §rhas been set to §7%{_rank}%", "4")
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_player}% §rhas been set to §7%{_rank}%", "6", true)
function mineroomsConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    return "%{_result}%"
function mineroomsConfigInteger(find: text, mode: text="extract", data: integer=0) :: integer:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    set {_result} to {_result} parsed as integer
    if {_result} is not set:
        set {_result} to 0
    return {_result}
function mineroomsConfigItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}

function mineroomsData(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    return "%{_result}%"
function mineroomsDataInteger(find: text, mode: text="extract", data: integer=0) :: integer:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    set {_result} to "%{_result}%" parsed as integer
    if {_result} is not set:
        set {_result} to 0
    return {_result}

function mineroomsDataBoolean(find: text, mode: text="extract", data: boolean=false) :: boolean:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    if {_result} is not set:
        set {_result} to false
    return {_result}
function mineroomsDataItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}
function mineroomsServerConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    return {_result}
function mineroomsServerConfigBoolean(find: text, mode: text="extract", data: boolean=false) :: boolean:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    if {_result} is not set:
        set {_result} to false
    return {_result}
function mineroomsServerConfigItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}
#                                      deleteAndDrop functions                                                                          #
function deleteAndDrop(player: player, location: location, dropItem: item):
    set {_fortune} to level of fortune of {_player}'s tool
    if {_fortune} is 1:
        set {_rng} to random integer between 1 and 2
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 2:
        set {_rng} to random integer between 1 and 3
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 3:
        set {_rng} to random integer between 1 and 4
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 4:
        set {_rng} to random integer between 2 and 5
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} is 5:
        set {_rng} to random integer between 2 and 6
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} > 5:
        set {_rng} to random integer between 5 and {_fortune}
        set {_r} to {_rng}
        set {_g} to {_r}
        set {_c} to {_g}
        if {_g} >= 65:
            set {_gg} to {_g} / 64
            set {_gg} to ceil({_gg})
            loop {_gg} times:
                if {_c} < 64:
                    drop {_c} of {_dropItem} at {_location}
                else:
                    drop 64 of {_dropItem} at {_location}
                remove 64 from {_c}
        else:
            drop {_g} of {_dropItem} at {_location}
        experienceDrop({_location}, 5, {_rng})
        #drop {_r} of {_dropItem} at {_location}
    else:
        drop {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
#                                      deleteAndDropMore functions                                                                          #
function deleteAndDropMore(player: player, location: location, dropItem: item, boosted: boolean=false):
    set {_fortune} to level of fortune of {_player}'s tool
    if {_fortune} is 1:
        set {_rng} to random integer between 3 and 8
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 2:
        set {_rng} to random integer between 4 and 12
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 3:
        set {_rng} to random integer between 5 and 18
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 4:
        set {_rng} to random integer between 7 and 25
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} is 5:
        set {_rng} to random integer between 15 and 34
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} > 5:
        set {_rng} to random integer between 15 and {_fortune}
        set {_r} to {_rng}
        set {_g} to {_r}
        set {_c} to {_g}
        if {_g} >= 65:
            set {_gg} to {_g} / 64
            set {_gg} to ceil({_gg})
            loop {_gg} times:
                if {_c} < 64:
                    drop {_c} of {_dropItem} at {_location}
                else:
                    drop 64 of {_dropItem} at {_location}
                remove 64 from {_c}
        else:
            drop {_g} of {_dropItem} at {_location}
        experienceDrop({_location}, 5, {_rng})
    else:
        set {_rng} to random integer between 3 and 5
        drop {_rng} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
#                                       deleteAndDropNoFortune function                                                                        #
function deleteAndDropNoFortune(player: player, location: location, dropItem: item):
    drop {_dropItem} at {_location}
#                                       experienceDrop function                                                                                 #
function experienceDrop(location: location, minxp: integer=1, maxxp: integer=3):
    set {_xp} to random number between {_minxp} and {_maxxp}
    spawn {_xp} of experience orb at {_location}
#                                       Inventory Saver functions                                                                         #
function mineroomsInventorySaver(player: player, drop: boolean=false):
    set {_s} to 0
    if {_helmet} is not set:
        set {_helmet} to air
    if {_chestplate} is not set:
        set {_chestplate} to air
    if {_leggings} is not set:
        set {_leggings} to air
    if {_boots} is not set:
        set {_boots} to air
    if {_off} is not set:
        set {_off} to air
    loop 36 times:
        set {_i} to slot {_s} of {_player}'s inventory
        set {_data::*} to "%{_i}%" split by " "
        set {_c} to {_data::1}
        set {_c} to {_c} parsed as integer
        if "%{_i}%" doesn't contain "0" or "1" or "2" or "3" or "4" or "5" or "6" or "7" or "8" or "9":
            set {_c} to 1
        set yaml value "inventory.%{_player}%.%{_s}%" from "bck.manager.minerooms.data" to {_i}
        if {_drop} is true:
            drop {_i} at {_player}'s location
        #broadcast "Item: %{_i}%/%{_s}%"
        add 1 to {_s}
    if {_drop} is true:
        drop {_player}'s helmet at {_player}'s location
        drop {_player}'s chestplate at {_player}'s location
        drop {_player}'s leggings at {_player}'s location
        drop {_player}'s boots at {_player}'s location
        drop offhand tool of {_player} at {_player}'s location
    set yaml value "inventory.%{_player}%.helmet" from "bck.manager.minerooms.data" to {_player}'s helmet
    set yaml value "inventory.%{_player}%.chestplate" from "bck.manager.minerooms.data" to {_player}'s chestplate
    set yaml value "inventory.%{_player}%.leggings" from "bck.manager.minerooms.data" to {_player}'s leggings
    set yaml value "inventory.%{_player}%.boots" from "bck.manager.minerooms.data" to {_player}'s boots
    set yaml value "inventory.%{_player}%.off_hand" from "bck.manager.minerooms.data" to offhand tool of {_player}
    set yaml value "inventory.%{_player}%.location" from "bck.manager.minerooms.data" to {_player}'s location
    save "bck.manager.minerooms.data"
function mineroomsShopAbbrevNumber(v: integer) :: text:
    if {_v} >= 1000:
        if {_v} < 1000000:
            set {_v} to "%{_v} / 1000%k"
        else:
            set {_v} to "%{_v} / 1000000%m"
    else:
        set {_v} to "%{_v}%"
    return {_v}
on damage:
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if "%damage cause%" is "fall":
        if mineroomsData("levels.%{_name}%.fallDamage") is "false":
            if "%victim's gamemode%" is not "creative":
                cancel event
                stop
on damage:
    set {_name} to "%event-world%"
    replace "Niveau_" with "" in {_name}
    if "%type of attacker%" is not "player":
        stop
    if "%attacker's gamemode%" is not "creative":
        set {_x} to mineroomsData("levels.%{_name}%.decoCombat")
        if "%type of victim%" is "player":
            if mineroomsData("levels.%{_name}%.decoCombat") is "false":
                userData(attacker, "player.temp.decoCombat.active", "set", "true")
                set {_d} to mineroomsData("decoCombat.time")
                userData(attacker, "player.temp.decoCombat.cooldown", "set", mineroomsData("decoCombat.time"))
                userData(victim, "player.temp.decoCombat.active", "set", "true")
                userData(victim, "player.temp.decoCombat.attacker", "set", "%attacker's name%")
                userData(victim, "player.temp.decoCombat.cooldown", "set", mineroomsData("decoCombat.time"))
every 1 seconds:
    loop all players:
        set {_x} to loop-player
        if userData({_x}, "player.temp.decoCombat.active") is "true":
            set {_c} to userData({_x}, "player.temp.decoCombat.cooldown")
            set {_c} to "%{_c}%" parsed as integer
            if {_c} < 0:
                userData({_x}, "player.temp.decoCombat.active", "set", "false")
                stop
            add "%{_c}%" to {_args::*}
            send actionbar superLang("minerooms.decoCombat.active", {_x}, {_args::*}) to {_x}
            remove 1 from {_c}
            userData({_x}, "player.temp.decoCombat.cooldown", "set", "%{_c}%")

on quit:
    set {_a} to userData(player, "player.temp.decoCombat.active")
    if "%{_a}%" is "true":
        if "%player's gamemode%" is not "creative":
            kill player
on death:
    if userData(victim, "player.temp.decoCombat.active") is "true":
        # loop all players:
        #     add victim's name to {_args::*}
        #     add userData(victim, "player.temp.decoCombat.attaker") to {_args::*}
        #     send formatted superLang("minerooms.decoCombat.death", loop-player, {_args::*}) to loop-player
        userData(victim, "player.temp.decoCombat.active", "set", "false")
        userData(attacker, "player.temp.decoCombat.active", "set", "false")
        userData(victim, "player.temp.decoCombat.attacker", "set", "??")