on load:
    if {skripts::*} contains "bck_minerooms.sk":
        send "§6[§4BCK§6]§r Loading minerooms..." to console
        wait 2 seconds
        send "§6[§4BCK§6/§eMineRooms§6]§r Loaded successfully !" to console
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/config.yml" as "bck.manager.minerooms.config"
        load yaml "plugins/Skript/scripts/BCK/manager/minerooms/data.yml" as "bck.manager.minerooms.data"
        mineroomsLoad()
    else:
        broadcast "§6[§4BCK§6/§eMineRooms§6]§r Script loading cancel It require (bck_minerooms.sk)"
        unload script file "bck_minerooms.sk"
    stop
#                                      txtGiver command                                                                          #
command /txtGiver [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_i} to arg-1 parsed as item
            give {_i} to player
on tab complete of "/txtGiver":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to all items
command /msk [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_a} to arg-1
            replace "minecraft:" with "" in {_a}
            set {_r} to convertMinecraftToSkriptString({_a})
            send "§6[§4BCK§6]§r §d%{_a}% §e-> §b%{_r}%"
command /skm [<text>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            stop
        if arg-1 is set:
            set {_a} to arg-1
            set {_r} to convertSkriptToMinecraftString({_a}, true)
            send "§6[§4BCK§6]§r §d%{_a}% §e-> §b%{_r}%"
command /tg [<number=0>] [<number=10>]:
    trigger:
        if hasPermission(player, "server.owner") is false:
            send lang("core.cannotDoThis", player)
            kill player
            stop
        set {_c} to 0
        loop minecraftBaseItemsListItem():
            if {_c} < arg-2:
                if {_c} >= arg-1:
                    genericItemGive(player, loop-value)
                add 1 to {_c}
on tab complete of "/msk":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to minecraftBaseItemsList()
on tab complete of "/skm":
    if hasPermission(player, "server.owner") is false:
        stop
    set tab completions for position 1 to all items
#                                      minerooms command                                                                          #
command /minerooms [<text>] [<text>] [<offlineplayer>] [<text>]:
    aliases: /mr
    trigger:
        if arg-1 is not set:
            add command to {_args::*}
            send formatted superLang("minerooms.command.noOption", player, {_args::*}) to player
        if arg-1 is "rank":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            if arg-2 is not set:
                add command to {_args::*}
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.noSecondOption", player, {_args::*}) to player
            else if arg-2 is "set":
                if arg-3 is not set:
                    send formatted lang("minerooms.command.missingPlayer", player) to player
                else:
                    if arg-4 is not set:
                        send formatted lang("minerooms.command.missingRank", player) to player
                    else:
                        if mineroomsGetAllRanks() doesn't contain arg-4:
                            add arg-4 to {_args::*}
                            send formatted superLang("minerooms.command.unknownRank", player, {_args::*}) to player
                        else:
                            mineroomsSetRank(arg-3, arg-4, true)
            else if arg-2 is "remove":
                if arg-3 is not set:
                    send formatted lang("minerooms.command.missingPlayer", player) to player
                else:
                    if arg-4 is not set:
                        send formatted lang("minerooms.command.missingRank", player) to player
                    else:
                        if mineroomsGetAllRanks() doesn't contain arg-4:
                            add arg-4 to {_args::*}
                            send formatted superLang("minerooms.command.unknownRank", player, {_args::*}) to player
                        else:
                            if userData(arg-3, "player.rank") is arg-4:
                                mineroomsSetRank(arg-3, "default", true)
                            else:
                                add arg-3's name to {_args::*}
                                send formatted superLang("minerooms.command.hisDontHaveThisRank", player, {_args::*}) to player
            else if arg-2 is "list":
                set {_gui} to genericGui(lang("minerooms.command.ranks.list.gui.title", player), 5, true)
                set slot 22 of {_gui} to redstone block named "§4Wait.."
                userData(player, "data.inv", "set", "manager.minerooms.ranks.list.main")
                open {_gui} to player
                mineroomsRankListGuiUpdater(player)
            else:
                add arg-2 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
        else if arg-1 is "noclip":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            mineroomsNoClip(player)
        else if arg-1 is "lore":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            if arg-2 is not set:
                send formatted lang("minerooms.command.lore.translationKeyMissing", player) to player
                stop
            set {_i} to player's tool
            if {_i} is air:
                send formatted lang("minerooms.command.lore.handIsEmpty", player) to player
                stop
            set line 2 of lore of player's tool to "§d<lang:minerooms.levels.%arg-2%>"
            send formatted lang("minerooms.command.lore.success", player) to player
        else if arg-1 is "restock":
            if hasPermission(player, "op") is false:
                add arg-1 to {_args::*}
                send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
                stop
            set {_i} to player's tool
            if {_i} is air:
                send formatted lang("minerooms.command.restock.handIsEmpty", player) to player
                stop
            set line 2 of lore of player's tool to "§b<restock:default>"
            send formatted lang("minerooms.command.restock.success", player) to player
        else:
            add arg-1 to {_args::*}
            send formatted superLang("minerooms.command.unknownOption", player, {_args::*}) to player
#                                      mineroomsLoad functions                                                                          #
function mineroomsLoad():
    set {_data::*} to yaml list "data.minerooms.load.options" from "bck.manager.minerooms.config"
    if file "plugins/MineRooms/config.yml" doesn't exist:
        superLog("§6[§4BCK§6/§eMineRooms§6]§r §eInitialization..", "6.")
        create script "plugins/MineRooms/config.yml"
        write "##                                                                                                                              " at line 1 to file "plugins/MineRooms/config.yml"
        write "##                   ,,                                                                                 " at line 2 to file "plugins/MineRooms/config.yml"
        write "## `7MMM.     ,MMF'  db                          `7MM""""Mq.                                             " at line 3 to file "plugins/MineRooms/config.yml"
        write "##   MMMb    dPMM                                  MM   `MM.                                            " at line 4 to file "plugins/MineRooms/config.yml"
        write "##   M YM   ,M MM  `7MM  `7MMpMMMb.  .gP""Ya        MM   ,M9  ,pW""Wq.   ,pW""Wq.`7MMpMMMb.pMMMb.  ,pP""Ybd " at line 5 to file "plugins/MineRooms/config.yml"
        write "##   M  Mb  M' MM    MM    MM    MM ,M'   Yb       MMmmdM9  6W'   `Wb 6W'   `Wb MM    MM    MM  8I   `"" " at line 6 to file "plugins/MineRooms/config.yml"
        write "##   M  YM.P'  MM    MM    MM    MM 8M""""""       MM  YM.  8M     M8 8M     M8 MM    MM    MM  `YMMMa. " at line 7 to file "plugins/MineRooms/config.yml"
        write "##   M  `YM'   MM    MM    MM    MM YM.    ,       MM   `Mb.YA.   ,A9 YA.   ,A9 MM    MM    MM  L.   I8 " at line 8 to file "plugins/MineRooms/config.yml"
        write "## .JML. `'  .JMML..JMML..JMML  JMML.`Mbmmd'     .JMML. .JMM.`Ybmd9'   `Ybmd9'.JMML  JMML  JMML.M9mmmP' " at line 9 to file "plugins/MineRooms/config.yml"
        write "" at line 10 to file "plugins/MineRooms/config.yml"
        write "##   ___           ___ _            _    _          _       _     _   " at line 11 to file "plugins/MineRooms/config.yml"
        write "##  / __\_   _    / __\ | __ _  ___| | _| | ___ __ (_) __ _| |__ | |_ " at line 12 to file "plugins/MineRooms/config.yml"
        write "## /__\// | | |  /__\// |/ _` |/ __| |/ / |/ / '_ \| |/ _` | '_ \| __|" at line 13 to file "plugins/MineRooms/config.yml"
        write "##/ \/  \ |_| | / \/  \ | (_| | (__|   <|   <| | | | | (_| | | | | |_ " at line 14 to file "plugins/MineRooms/config.yml"
        write "##\_____/\__, | \_____/_|\__,_|\___|_|\_\_|\_\_| |_|_|\__, |_| |_|\__|" at line 15 to file "plugins/MineRooms/config.yml"
        write "##       |___/                                        |___/           " at line 16 to file "plugins/MineRooms/config.yml"
        write "" at line 17 to file "plugins/MineRooms/config.yml"
        set {_x} to 18
        set {_c} to listCounter({_data::*})
        loop {_data::*}:
            write loop-value at line {_x} to file "plugins/MineRooms/config.yml"
            add 1 to {_x}
        wait 3 ticks
        superLog("§6[§4BCK§6/§eMineRooms§6]§r §eInitialization §nComplete§r§e !", "6.4")
    wait 3 ticks
    load yaml "plugins/MineRooms/config.yml" as "bck.server.minerooms.config"
    superLog("§6[§4BCK§6/§eMineRooms§6]§r §aLoaded file succeffully !", "6.4")
    wait 2 ticks

    mineroomsData("chat.message", "set", mineroomsServerConfig("chat.message"))

    loop yaml node keys "levels" from "bck.server.minerooms.config":
        add loop-node to {_levelsList::*}
    loop {_levelsList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_levelName} to mineroomsServerConfig("%loop-value%")
        if {_levelName} is "<none>":
            set {_levelName} to "??"
        mineroomsData("%loop-value%", "set", {_levelName})
    
    loop yaml node keys "restock" from "bck.server.minerooms.config":
        add loop-node to {_restockList::*}
    loop {_restockList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        loop yaml node keys "restock.%{_r}%" from "bck.server.minerooms.config":
            add loop-node to {_dataList::*}
        loop {_dataList::*}:
            set {_i} to loop-value-2
            set {_ii} to loop-value-2
            set {_i::*} to {_i} split by "."
            set {_i} to {_i::3}
            replace all "_" with " " in {_i}
            
            set {_restockCount} to yaml value "%{_ii}%.count" from "bck.server.minerooms.config" 
            set {_restockChance} to yaml value "%{_ii}%.chance" from "bck.server.minerooms.config"
            set {_restockCount} to "%{_restockCount}%" parsed as integer
            set {_restockChance} to "%{_restockChance}%" parsed as integer
            set {_restockCustomName} to mineroomsServerConfig("%{_ii}%.custom.name")
            set {_restockCustomLores::*} to yaml list "%{_ii}%.custom.lores" from "bck.server.minerooms.config"
            if "%{_restockCount}%" is "<none>":
                set {_restockCount} to 1
            if "%{_restockChance}%" is "<none>":
                set {_restockChance} to 100
            mineroomsData("%{_ii}%.count", "set", "%{_restockCount}%")
            mineroomsData("%{_ii}%.chance", "set", "%{_restockChance}%")
            if {_restockCustomName} is set:
                mineroomsData("%{_ii}%.custom.name", "set", {_restockCustomName})
            if {_restockCustomLores::*} is set:
                set yaml list "%{_ii}%.custom.lores" from "bck.manager.minerooms.data" to {_restockCustomLores::*}
                save "bck.manager.minerooms.data"

    loop yaml node keys "ranks" from "bck.server.minerooms.config":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_rankName} to mineroomsServerConfig("%loop-value%.name")
        if {_rankName} is not set:
            set {_rankName} to "minerooms.ranks.%{_r}%.name"
        set {_perms::*} to yaml list "%loop-value%.perms" from "bck.server.minerooms.config"
        if "%{_perms::*}%" is not "<none>":
            set {_rank.perms::*} to yaml list "%loop-value%.perms" from "bck.server.minerooms.config"
            mineroomsData("%loop-value%.name", "set", {_rankName})
            set yaml list "%loop-value%.perms" from "bck.manager.minerooms.data" to {_rank.perms::*}
            save "bck.manager.minerooms.data"
            clear {_rank.perms::*}
    wait 5 ticks
    superLog("§6[§4BCK§6/§eMineRooms§6]§r §eConfig has been §aupdated §e!", "6.4")

#                                      tab complete minerooms                                                                          #
on tab complete of "/minerooms" or "/mr":
    if hasPermission(player, "server.command.minerooms") is false:
        stop
    if hasPermission(player, "op") is true:
        add "rank" to {_data::*}
        add "noclip" to {_data::*}
        add "lore" to {_data::*}
        add "restock" to {_data::*}
    set tab completions for position 1 to {_data::*}
    if tab arg-1 is "rank":
        if hasPermission(player, "op") is true:
            clear {_data::*}
            add "set" to {_data::*}
            add "remove" to {_data::*}
            add "list" to {_data::*}
            set tab completions for position 2 to {_data::*} 
            if tab arg-2 is "set":
                set tab completions for position 3 to all players
                if tab arg-3 is set:
                    set tab completions for position 4 to mineroomsGetAllRanks()
            else if tab arg-2 is "remove":
                set tab completions for position 3 to all players
                if tab arg-3 is set:
                    set tab completions for position 4 to userData(player, "player.rank")
    else if tab arg-1 is "lore":
        if hasPermission(player, "op") is true:

    else if tab arg-1 is "restock":
        if hasPermission(player, "op") is true:

on join:
    if mineroomsGetRank(player) is "<none>":
        mineroomsSetRank(player, "wanderer", true)
    else if mineroomsGetAllRanks() doesn't contain userData(player, "player.rank"):
        mineroomsSetRank(player, "wanderer", true)
    if userData(player, "data.language") is "<none>":
        userData(player, "data.language", "set", languageConfig("data.defaultLanguage"))
command /bck_dev:
    trigger:
        set {_se} to selector(player)
        loop getLanguages():
            set {_x} to loop-value
            load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
            set {_key} to "minerooms.firstJoin.pleaseSelectYourLanguage"
            set {_r} to yaml value {_key} from "bck.manager.language.%{_x}%"
            if "%{_r}%" is "<none>":
                set {_r} to {_key}
            add {_x} to {_args::*}
            set {_num} to 0
            loop {_args::*}:
                set {_v} to loop-value-2
                replace all "<arg%{_num}%>" with {_v} in {_r}
                add 1 to {_num}
            send formatted {_r} to player
            clear {_args::*}
on first join:
    #userData(player, "minerooms.temp.firstJoin", "set", "true")
    set {_se} to selector(player)
    loop getLanguages():
        set {_x} to loop-value
        load yaml "plugins/Skript/scripts/BCK/manager/language/language/%{_x}%.yml" as "bck.manager.language.%{_x}%"
        set {_key} to "minerooms.firstJoin.pleaseSelectYourLanguage"
        set {_r} to yaml value {_key} from "bck.manager.language.%{_x}%"
        if "%{_r}%" is "<none>":
            set {_r} to {_key}
        add {_x} to {_args::*}
        set {_num} to 0
        loop {_args::*}:
            set {_v} to loop-value-2
            replace all "<arg%{_num}%>" with {_v} in {_r}
            add 1 to {_num}
        send formatted {_r} to player
        clear {_args::*}
    wait 5 seconds
    wait 1 seconds
    make console execute command "/mvtp %player's name% %mineroomsGetLevel(player, 0)%"
    # superLog("§6[§4BCK§6]§r §7%{_se}% §ris loading..", "4")
    # superLog("§6[§4BCK§6]§r §7%player's name% §ris loading..", "6", true)
# on any move:
#     if userData(player, "minerooms.temp.firstJoin") is "true":
#         make console execute command "/mvtp %player's name% %mineroomsGetLevel(player, 0)%"
#         userData(player, "minerooms.temp.firstJoin", "set", "false")
#         set {_se} to selector(player)
#         superLog("§6[§4BCK§6]§r §7%{_se}% §rfinished his loading..", "4")
#         superLog("§6[§4BCK§6]§r §7%player's name% §rfinished his loading..", "6", true)
on place:
    set {_b} to event-block
    set {_i} to event-item
    set {_cx} to x-coordinate of {_b}
    set {_cy} to y-coordinate of {_b}
    set {_cz} to z-coordinate of {_b}
    set {_cw} to {_b}'s world
    set {_x} to line 2 of lore of {_i}
    replace "§d" with "" in {_x}
    replace "§b" with "" in {_x}
    if {_x} contain "<lang:":
        set {_data::*} to {_x} split by ":"
        set {_k} to {_data::2}
        replace ">" with "" in {_k}
        set {_blocks::*} to yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.data"
        add "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%|%{_k}%" to {_blocks::*}
        set yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.data" to {_blocks::*}
        save yaml "bck.manager.minerooms.data"
        add {_k} to {_args::*}
        send actionbar formatted superLang("minerooms.command.lore.added", player, {_args::*}) to player
        play sound "entity.experience_orb.pickup" with volume 0.3 for player
    else if {_x} contain "<restock:":
        set {_data::*} to {_x} split by ":"
        set {_k} to {_data::2}
        replace ">" with "" in {_k}
        set {_supplys::*} to yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.data"
        add "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%|%{_k}%" to {_supplys::*}
        set yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.data" to {_supplys::*}
        save yaml "bck.manager.minerooms.data"
        add {_k} to {_args::*}
        send actionbar formatted superLang("minerooms.command.restock.added", player, {_args::*}) to player
        play sound "entity.experience_orb.pickup" with volume 0.3 for player
on break:
    set {_b} to event-block
    set {_i} to event-item
    set {_cx} to x-coordinate of {_b}
    set {_cy} to y-coordinate of {_b}
    set {_cz} to z-coordinate of {_b}
    set {_cw} to {_b}'s world
    set {_blocks::*} to yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.data"
    set {_supplys::*} to yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.data"
    if {_blocks::*} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
        loop {_blocks::*}:
            set {_x} to loop-value
            set {_xs::*} to {_x} split by "|"
            if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                add {_xs::5} to {_args::*}
                send actionbar formatted superLang("minerooms.command.lore.removed", player, {_args::*}) to player
                play sound "block.note_block.bit" with volume 0.3 with pitch 0 for player
            else:
                add {_x} to {_r::*}
        set yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.data" to {_r::*}
        save yaml "bck.manager.minerooms.data"
    else if {_supplys::*} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
        loop {_supplys::*}:
            set {_x} to loop-value
            set {_xs::*} to {_x} split by "|"
            if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                add {_xs::5} to {_args::*}
                send actionbar formatted superLang("minerooms.command.restock.removed", player, {_args::*}) to player
                play sound "block.note_block.bit" with volume 0.3 with pitch 0 for player
            else:
                add {_x} to {_r::*}
        set yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.data" to {_r::*}
        save yaml "bck.manager.minerooms.data"
on right click:
    set {_e} to event-entity
    set {_b} to event-block
    if {_b} is set:
        set {_cx} to x-coordinate of {_b}
        set {_cy} to y-coordinate of {_b}
        set {_cz} to z-coordinate of {_b}
        set {_cw} to {_b}'s world
        set {_blocks::*} to yaml list "minerooms.lang.blocks" from "bck.manager.minerooms.data"
        set {_supplys::*} to yaml list "minerooms.restock.supplys" from "bck.manager.minerooms.data"
        if {_blocks::*} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
            loop {_blocks::*}:
                set {_x} to loop-value
                set {_xs::*} to {_x} split by "|"
                if {_x} contain "%{_cx}%|%{_cy}%|%{_cz}%|%{_cw}%":
                    if player cannot hold 1 written book:
                        cancel event
                        stop
                    cancel event
                    set {_x} to userData(player, "data.language")
                    if "%{_x}%" is "<none>":
                        set {_x} to languageConfig("data.defaultLanguage")
                        userData(player, "data.language", "set", "en")
                    set {_pages::*} to yaml list "%{_xs::5}%.pages" from "bck.manager.language.%{_x}%"
                    set {_name} to lang("%{_xs::5}%.name", player)
                    set {_a} to lang("%{_xs::5}%.author", player)
                    set {_w} to ""
                    loop {_pages::*}:
                        set {_v} to loop-value-2
                        if loop-index-2 is "1":
                            set {_w} to "'{""text"":""%{_v}%""}'"
                        else:
                            set {_w} to "%{_w}%,'{""text"":""%{_v}%""}'"
                    set {_cmd} to "/give %player's name% written_book{pages:[%{_w}%],title:""%{_name}%"",author:""%{_a}%""}"
                    make console execute command {_cmd}
                    set {_ss} to 0
                    loop 36 times:
                        set {_i} to slot {_ss} of player's inventory
                        if "%{_i}%" is "written book":
                            open book {_i} to player
                            set slot {_ss} of player's inventory to air
                            exit loop
                        add 1 to {_ss}
    else if {_e} is set:

function mineroomsTravel(player: player, level: integer=-1, message: boolean=true):
    set {_x} to mineroomsGetLevel({_player}, {_level})
    make console execute command "/mvtp %{_player}'s name% %mineroomsGetLevel({_player}, {_level})%"
    wait 1 tick
    send title mineroomsGetLevel({_player}, {_level}) to {_player}
on chat:
    cancel event
    loop all players:
        set {_x} to loop-player
        if {_x}'s world is player's world:
            set {_mb} to mineroomsData("chat.message")
            set {_mb} to "%{_mb}%"
            set {_c} to 0
            add player's name to {_args::*}
            add message to {_args::*}
            loop {_args::*}:
                set {_v} to loop-value-2
                replace all "<arg%{_c}%>" with "%{_v}%" in {_mb}
                add 1 to {_c}
            send formatted {_mb} to {_x}
            send formatted "§6[§b%player's world%§6]§r %{_mb}%" to console
function mineroomsNoClip(player: player):
    set {_gui} to genericGui(lang("minerooms.command.noClip.gui.title", {_player}), 5, true)
    set slot 22 of {_gui} to redstone block named "§4Wait.."
    userData({_player}, "data.inv", "set", "manager.minerooms.noClip.main")
    open {_gui} to {_player}
    mineroomsNoClipGuiUpdater({_player})
function mineroomsNoClipGuiUpdater(player: player):
    set {_gui} to {_player}'s current inventory
    set slot 22 of {_gui} to air
    set {_sc} to 10
    set {_gc} to 0
    loop 24 times:
        if {_gc} is 10 or 19 or 28:
            add 7 to {_gc}
        else if {_gc} is 40:
            add 1 to {_gc}
        set slot {_gc} of {_gui} to yellow stained glass pane named "§l"
        add 1 to {_gc}
    loop yaml node keys "levels" from "bck.manager.minerooms.data":
        add loop-node to {_levelsList::*}
    loop {_levelsList::*}:
        if {_sc} = 17 or 27:
            add 2 to {_sc}
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_levelName} to mineroomsData("%loop-value%")
        set {_levelName} to configLang({_levelName}, {_player})
        if {_levelName} is not lang("minerooms.command.noClip.levels.-1", {_player}):
            if {_levelName} is "<none>":
                set {_levelName} to "??"
            replace all "_" with " " in {_levelName}
            set {_i} to paper named {_levelName}
            add {_levelName} to {_args::*}
            set line 2 of lore of {_i} to superLang("minerooms.command.noClip.gui.clickToTeleport", {_player}, {_args::*})
            set slot {_sc} of {_gui} to {_i}
            clear {_args::*}
            add 1 to {_sc}
    userData({_player}, "data.inv", "set", "manager.minerooms.noClip.main")
function mineroomsRankListGuiUpdater(player: player):
    set {_gui} to {_player}'s current inventory
    set slot 22 of {_gui} to air
    set {_sc} to 10
    set {_gc} to 0
    loop 24 times:
        if {_gc} is 10 or 19 or 28:
            add 7 to {_gc}
        else if {_gc} is 40:
            add 1 to {_gc}
        set slot {_gc} of {_gui} to yellow stained glass pane named "§l"
        add 1 to {_gc}
    loop yaml node keys "ranks" from "bck.manager.minerooms.data":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        set {_rankName} to mineroomsData("%loop-value%.name")
        if {_rankName} is not set:
            set {_rankName} to "minerooms.ranks.%{_r}%.name"
        set {_perms::*} to yaml list "%loop-value%.perms" from "bck.manager.minerooms.data"
        if "%{_perms::*}%" is not "<none>":
            set {_rank.perms::*} to yaml list "%loop-value%.perms" from "bck.manager.minerooms.data"
        set {_i} to paper named configLang({_rankName}, {_player})
        set line 1 of lore of {_i} to lang("minerooms.command.ranks.list.gui.permissions", {_player})
        set {_rf} to 2
        loop {_rank.perms::*}:
            set {_x} to loop-value-2
            add "%{_x}%" to {_args::*}
            set line {_rf} of lore of {_i} to superLang("minerooms.command.ranks.list.gui.genericPermission", {_player}, {_args::*})
            add 1 to {_rf}
            clear {_args::*}
        set slot {_sc} of {_gui} to {_i}
        add 1 to {_sc}
        wait 1 tick
    userData({_player}, "data.inv", "set", "manager.minerooms.ranks.list.main")
on inventory click:
    if userData(player, "data.inv") is "false":
        stop
    if userData(player, "data.inv") is "manager.minerooms.noClip.main":
        cancel event
        set {_gui} to player's current inventory
        set {_i} to event-slot
        set {_t} to type of {_i}
        set {_n} to display name of {_i}
        set {_u} to {_n}
        set {_a} to item amount of event-slot
        if "%{_t}%" contain "barrier":
            if {_u} contain "Back":
                close player's inventory
        else:
            if "%{_t}%" contain "paper":
                loop yaml node keys "levels" from "bck.manager.minerooms.data":
                    add loop-node to {_levelsList::*}
                loop {_levelsList::*}:
                    if {_sc} = 17 or 27:
                        add 2 to {_sc}
                    set {_r} to loop-value
                    set {_r::*} to {_r} split by "."
                    set {_r} to {_r::2}
                    set {_levelName} to mineroomsData("%loop-value%")
                    set {_levelNameBis} to configLang({_levelName}, player, "language", true)
                    set {_levelName} to configLang({_levelName}, player)
                    replace all "_" with " " in {_levelName}
                    if {_u} is {_levelName}:
                        close player's inventory
                        make console execute command "/mvtp %player's name% %{_levelNameBis}%"
    else if userData(player, "data.inv") is "manager.minerooms.ranks.list.main":
        cancel event
        set {_gui} to player's current inventory
        set {_i} to event-slot
        set {_t} to type of {_i}
        set {_n} to display name of {_i}
        set {_u} to {_n}
        set {_a} to item amount of event-slot
        if "%{_t}%" contain "barrier":
            if {_u} contain "Back":
                close player's inventory
function mineroomsGetLevel(player: player, num: integer=-1) :: text:
    return configLang(mineroomsData("levels.%{_num}%"), {_player})
#                                      mineroomsGetAllRanks functions                                                                          #
function mineroomsGetAllRanks() :: objects:
    loop yaml node keys "ranks" from "bck.manager.minerooms.data":
        add loop-node to {_ranksList::*}
    loop {_ranksList::*}:
        set {_r} to loop-value
        set {_r::*} to {_r} split by "."
        set {_r} to {_r::2}
        add "%{_r}%" to {_return::*}
    return {_return::*}
#                                      mineroomsSetRank functions                                                                          #
function mineroomsSetRank(player: player, rank: text="wanderer", autoPerm: boolean=false):
    userData({_player}, "player.rank", "set", {_rank})
    set {_s} to selector({_player})
    superLog("§6[§4BCK§6/§eMineRooms§6]§r Rank of §7%{_s}% §rhas been set to §7%{_rank}%", "3")
    superLog("§6[§4BCK§6/§eMineRooms§6]§r Rank of §7%{_player}'s name% §rhas been set to §7%{_rank}%", "6", true)
    if {_autoPerm} is true:
        loop {server.permission.%{_player}'s name%.list::*}:
            if loop-value is not "server.owner":
                removePermission({_player}, loop-value, true)
        loop mineroomsGetRankPerms({_rank}):
            set {_x} to loop-value
            if "%{_x}%" contain "permissions":
                set {_data::*} to "%{_x}%" split by "."
                set {_w} to {_data::2}
                loop mineroomsGetRankPerms({_w}):
                    set {_xx} to loop-value-2
                    if {_xx} doesn't contain "permission":
                        addPermission({_player}, {_xx}, true)
            else:
                addPermission({_player}, {_x}, true)
#                                      mineroomsGetRank functions                                                                          #
function mineroomsGetRank(player: player) :: text:
    set {_r} to userData({_player}, "player.rank")
    return "%{_r}%"
#                                      mineroomsGetRankPerms functions                                                                          #
function mineroomsGetRankPerms(rank: text="?", player: text="?") :: objects:
    if {_rank} is "?":
        if {_player} is not "?":
            set {_player} to {_player} parsed as player
            set {_rank} to userData({_player}, "player.rank")
        set {_perms::*} to yaml list "ranks.%{_rank}%.perms" from "bck.manager.minerooms.data"
    else:
        set {_perms::*} to yaml list "ranks.%{_rank}%.perms" from "bck.manager.minerooms.data"
    return {_perms::*}
    
    set {_s} to selector({_player})
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_s}% §rhas been set to §7%{_rank}%", "4")
    superLog("§6[§4BCK§6/§eMineRooms§6]§r rank of §7%{_player}% §rhas been set to §7%{_rank}%", "6", true)
function mineroomsConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    return "%{_result}%"
function mineroomsConfigInteger(find: text, mode: text="extract", data: integer=0) :: integer:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    set {_result} to {_result} parsed as integer
    if {_result} is not set:
        set {_result} to 0
    return {_result}
function mineroomsConfigItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.config"
            save yaml "bck.manager.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
            save yaml "bck.manager.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.config" to {_data}
        save yaml "bck.manager.minerooms.config"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}

function mineroomsData(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    return "%{_result}%"
function mineroomsDataInteger(find: text, mode: text="extract", data: integer=0) :: integer:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    set {_result} to "%{_result}%" parsed as integer
    if {_result} is not set:
        set {_result} to 0
    return {_result}

function mineroomsDataBoolean(find: text, mode: text="extract", data: boolean=false) :: boolean:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    if {_result} is not set:
        set {_result} to false
    return {_result}
function mineroomsDataItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.manager.minerooms.data"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.manager.minerooms.data"
            save yaml "bck.manager.minerooms.data"
        else:
            set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
            save yaml "bck.manager.minerooms.data"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.manager.minerooms.data" to {_data}
        save yaml "bck.manager.minerooms.data"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}
function mineroomsServerConfig(find: text, mode: text="extract", data: text="") :: text:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    return {_result}
function mineroomsServerConfigBoolean(find: text, mode: text="extract", data: boolean=false) :: boolean:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    if {_result} is not set:
        set {_result} to false
    return {_result}
function mineroomsServerConfigItem(find: text, mode: text="extract", data: item=air) :: item:
    if {_mode} is "extract":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} isn't set:
            if {_data} isn't empty:
                set {_result} to {_data}
    else if {_mode} is "delete":
        set {_result} to yaml value "%{_find}%" from "bck.server.minerooms.config"
        if {_result} is set:
            delete yaml value "%{_find}%" from "bck.server.minerooms.config"
            save yaml "bck.server.minerooms.config"
        else:
            set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
            save yaml "bck.server.minerooms.config"
    else if {_mode} is "set":
        set yaml value "%{_find}%" from "bck.server.minerooms.config" to {_data}
        save yaml "bck.server.minerooms.config"
    set {_result} to {_result} parsed as item
    if "%{_result}%" is "<none>":
        set {_result} to air
    return {_result}
#                                      deleteAndDrop functions                                                                          #
function deleteAndDrop(player: player, location: location, dropItem: item):
    set {_fortune} to level of fortune of {_player}'s tool
    if {_fortune} is 1:
        set {_rng} to random integer between 1 and 2
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 2:
        set {_rng} to random integer between 1 and 3
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 3:
        set {_rng} to random integer between 1 and 4
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 4:
        set {_rng} to random integer between 2 and 5
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} is 5:
        set {_rng} to random integer between 2 and 6
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} > 5:
        set {_rng} to random integer between 5 and {_fortune}
        set {_r} to {_rng}
        set {_g} to {_r}
        set {_c} to {_g}
        if {_g} >= 65:
            set {_gg} to {_g} / 64
            set {_gg} to ceil({_gg})
            loop {_gg} times:
                if {_c} < 64:
                    drop {_c} of {_dropItem} at {_location}
                else:
                    drop 64 of {_dropItem} at {_location}
                remove 64 from {_c}
        else:
            drop {_g} of {_dropItem} at {_location}
        experienceDrop({_location}, 5, {_rng})
        #drop {_r} of {_dropItem} at {_location}
    else:
        drop {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
#                                      deleteAndDropMore functions                                                                          #
function deleteAndDropMore(player: player, location: location, dropItem: item, boosted: boolean=false):
    set {_fortune} to level of fortune of {_player}'s tool
    if {_fortune} is 1:
        set {_rng} to random integer between 3 and 8
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 2:
        set {_rng} to random integer between 4 and 12
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 3:
        set {_rng} to random integer between 5 and 18
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
    else if {_fortune} is 4:
        set {_rng} to random integer between 7 and 25
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} is 5:
        set {_rng} to random integer between 15 and 34
        set {_r} to {_rng} + {_fortune}
        drop {_r} of {_dropItem} at {_location}
        experienceDrop({_location}, 2, {_rng})
    else if {_fortune} > 5:
        set {_rng} to random integer between 15 and {_fortune}
        set {_r} to {_rng}
        set {_g} to {_r}
        set {_c} to {_g}
        if {_g} >= 65:
            set {_gg} to {_g} / 64
            set {_gg} to ceil({_gg})
            loop {_gg} times:
                if {_c} < 64:
                    drop {_c} of {_dropItem} at {_location}
                else:
                    drop 64 of {_dropItem} at {_location}
                remove 64 from {_c}
        else:
            drop {_g} of {_dropItem} at {_location}
        experienceDrop({_location}, 5, {_rng})
    else:
        set {_rng} to random integer between 3 and 5
        drop {_rng} of {_dropItem} at {_location}
        experienceDrop({_location}, 1, {_rng})
#                                       deleteAndDropNoFortune function                                                                        #
function deleteAndDropNoFortune(player: player, location: location, dropItem: item):
    drop {_dropItem} at {_location}
#                                       experienceDrop function                                                                                 #
function experienceDrop(location: location, minxp: integer=1, maxxp: integer=3):
    set {_xp} to random number between {_minxp} and {_maxxp}
    spawn {_xp} of experience orb at {_location}
#                                       Inventory Saver functions                                                                         #
function mineroomsInventorySaver(player: player, drop: boolean=false):
    set {_s} to 0
    if {_helmet} is not set:
        set {_helmet} to air
    if {_chestplate} is not set:
        set {_chestplate} to air
    if {_leggings} is not set:
        set {_leggings} to air
    if {_boots} is not set:
        set {_boots} to air
    if {_off} is not set:
        set {_off} to air
    loop 36 times:
        set {_i} to slot {_s} of {_player}'s inventory
        set {_data::*} to "%{_i}%" split by " "
        set {_c} to {_data::1}
        set {_c} to {_c} parsed as integer
        if "%{_i}%" doesn't contain "0" or "1" or "2" or "3" or "4" or "5" or "6" or "7" or "8" or "9":
            set {_c} to 1
        set yaml value "inventory.%{_player}%.%{_s}%" from "bck.manager.minerooms.data" to {_i}
        if {_drop} is true:
            drop {_i} at {_player}'s location
        #broadcast "Item: %{_i}%/%{_s}%"
        add 1 to {_s}
    if {_drop} is true:
        drop {_player}'s helmet at {_player}'s location
        drop {_player}'s chestplate at {_player}'s location
        drop {_player}'s leggings at {_player}'s location
        drop {_player}'s boots at {_player}'s location
        drop offhand tool of {_player} at {_player}'s location
    set yaml value "inventory.%{_player}%.helmet" from "bck.manager.minerooms.data" to {_player}'s helmet
    set yaml value "inventory.%{_player}%.chestplate" from "bck.manager.minerooms.data" to {_player}'s chestplate
    set yaml value "inventory.%{_player}%.leggings" from "bck.manager.minerooms.data" to {_player}'s leggings
    set yaml value "inventory.%{_player}%.boots" from "bck.manager.minerooms.data" to {_player}'s boots
    set yaml value "inventory.%{_player}%.off_hand" from "bck.manager.minerooms.data" to offhand tool of {_player}
    set yaml value "inventory.%{_player}%.location" from "bck.manager.minerooms.data" to {_player}'s location
    save "bck.manager.minerooms.data"
function mineroomsShopAbbrevNumber(v: integer) :: text:
    if {_v} >= 1000:
        if {_v} < 1000000:
            set {_v} to "%{_v} / 1000%k"
        else:
            set {_v} to "%{_v} / 1000000%m"
    else:
        set {_v} to "%{_v}%"
    return {_v}